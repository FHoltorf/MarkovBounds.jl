<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Functionalities · MarkovBounds.jl</title><meta name="title" content="Functionalities · MarkovBounds.jl"/><meta property="og:title" content="Functionalities · MarkovBounds.jl"/><meta property="twitter:title" content="Functionalities · MarkovBounds.jl"/><meta name="description" content="Documentation for MarkovBounds.jl."/><meta property="og:description" content="Documentation for MarkovBounds.jl."/><meta property="twitter:description" content="Documentation for MarkovBounds.jl."/><meta property="og:url" content="https://FHoltorf.github.io/MarkovBounds.jl/functionalities/"/><meta property="twitter:url" content="https://FHoltorf.github.io/MarkovBounds.jl/functionalities/"/><link rel="canonical" href="https://FHoltorf.github.io/MarkovBounds.jl/functionalities/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">MarkovBounds.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../background/">Background</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorials/birth_death_process/">Analysis of a Birth-Death Processes</a></li><li><a class="tocitem" href="../tutorials/jump_diffusion_process/">Analysis of Cox-Ingersoll-Ross Model Modified by Jumps</a></li><li><a class="tocitem" href="../tutorials/optimal_control/">Optimal Population Control of Noisy Lotka-Volterra System</a></li></ul></li><li class="is-active"><a class="tocitem" href>Functionalities</a><ul class="internal"><li><a class="tocitem" href="#Problem-Specification"><span>Problem Specification</span></a></li><li><a class="tocitem" href="#Bounds-on-Stationary-Moments-of-Markov-Processes"><span>Bounds on Stationary Moments of Markov Processes</span></a></li><li><a class="tocitem" href="#Bounds-on-Transient-Moments-of-Markov-Processes"><span>Bounds on Transient Moments of Markov Processes</span></a></li><li><a class="tocitem" href="#Bounds-on-Stochastic-Optimal-Control-Problems"><span>Bounds on Stochastic Optimal Control Problems</span></a></li><li><a class="tocitem" href="#API"><span>API</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Functionalities</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Functionalities</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/FHoltorf/MarkovBounds.jl/blob/master/docs/src/functionalities.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Functionalities-of-MarkovBounds.jl"><a class="docs-heading-anchor" href="#Functionalities-of-MarkovBounds.jl">Functionalities of MarkovBounds.jl</a><a id="Functionalities-of-MarkovBounds.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Functionalities-of-MarkovBounds.jl" title="Permalink"></a></h1><h2 id="Problem-Specification"><a class="docs-heading-anchor" href="#Problem-Specification">Problem Specification</a><a id="Problem-Specification-1"></a><a class="docs-heading-anchor-permalink" href="#Problem-Specification" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MarkovBounds.MarkovProcess" href="#MarkovBounds.MarkovProcess"><code>MarkovBounds.MarkovProcess</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MarkovProcess</code></pre><p>An abstract type to define stochastic processes that are supported by MarkovBounds.jl. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FHoltorf/MarkovBounds.jl/blob/8420eb38a796e1e331aea0a29d46a99dc414e0f0/src/processes.jl#L5-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MarkovBounds.DriftProcess" href="#MarkovBounds.DriftProcess"><code>MarkovBounds.DriftProcess</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DriftProcess(x, f, X = FullSpace();
             iv = _variable(&quot;t&quot;), controls = [], poly_vars = Dict())</code></pre><p>constructor returns <code>DriftProcess</code> object with fields</p><ul><li><code>x</code> - vector containing the system state. Can be specified both as Variable type object       from DynamicPolynomials.jl or Num type object generated by ModelingToolkit.jl.        In the latter case, Variable variables with analogous names are generated automatically and       a dictionary is assembled that keeps track of this transformation.</li><li><code>f</code> - vector containing the drift function for the process. </li><li><code>iv</code> - independent variable of the process (usually time)</li><li><code>controls</code> - vector of control variables (empty if there are none)</li><li><code>poly_vars</code> - Dict mapping symbolic variables created by Catalyst.jl or ModelingToolkit.jl to generated Variable placeholders.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FHoltorf/MarkovBounds.jl/blob/8420eb38a796e1e331aea0a29d46a99dc414e0f0/src/processes.jl#L12-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MarkovBounds.JumpProcess" href="#MarkovBounds.JumpProcess"><code>MarkovBounds.JumpProcess</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">JumpProcess(x, a, h, X = FullSpace();
            iv = Variable(&quot;t&quot;), controls = [], poly_vars = Dict())</code></pre><p>constructor returns <code>JumpProcess</code> object with fields</p><ul><li><code>x</code> - vector containing the system state. Can be specified both as Variable type object       from DynamicPolynomials.jl or Num type object generated by Catalyst.jl/ModelingToolkit.jl.        In the latter case, Variable variables with analogous names are generated automatically and       a dictionary is assembled that keeps track of this transformation.</li><li><code>a</code> - vector containing the rate coefficients for each independent jump in the system</li><li><code>h</code> - vector of vectors containing the jump functions </li><li><code>X</code> - basic semialgebraic set enclosing the state space of the process</li><li><code>iv</code> - independent variable of the process (usually time)</li><li><code>controls</code> - vector of control variables (empty if there are none)</li><li><code>poly_vars</code> - Dict mapping symbolic variables created by Catalyst.jl or ModelingToolkit.jl to generated Variable placeholders.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FHoltorf/MarkovBounds.jl/blob/8420eb38a796e1e331aea0a29d46a99dc414e0f0/src/processes.jl#L40-L55">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MarkovBounds.ReactionProcess" href="#MarkovBounds.ReactionProcess"><code>MarkovBounds.ReactionProcess</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ReactionProcess(rn::ReactionSystem, params = Dict())</code></pre><p>constructor returns <code>ReactionProcess</code> object generated from Catalyst.jl <code>ReactionSystem</code> object with given parameters. The fields of ReactionProcess objects are</p><ul><li><code>ReactionSystem</code>- underlying ReactionSystem object as generated by Catalyst.jl</li><li><code>JumpProcess</code> - JumpProcess object describing a <code>JumpProcess</code> that is equivalent to the stochastic reaction network described by ReactionSystem</li><li><code>species_to_index</code> - Dictionary mapping chemical species to its internally used variable species<em>to</em>index</li><li><code>species_to_state</code> - Dictionary mapping species to equivalent state in the JumpProcess</li><li><code>state_to_species</code> - Dictionary mapping state in <code>JumpProcess</code> to species in reaction network</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FHoltorf/MarkovBounds.jl/blob/8420eb38a796e1e331aea0a29d46a99dc414e0f0/src/processes.jl#L76-L86">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MarkovBounds.DiffusionProcess" href="#MarkovBounds.DiffusionProcess"><code>MarkovBounds.DiffusionProcess</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DiffusionProcess(x, f, σ, X = FullSpace();
                 iv = _variable(&quot;t&quot;), controls = [], poly_vars = Dict())</code></pre><p>constructor returns <code>DiffusionProcess</code> object with fields</p><ul><li><code>x</code> - vector containing the system state. Can be specified both as Variable type object       from DynamicPolynomials.jl or Num type object generated by Catalyst.jl/ModelingToolkit.jl.        In the latter case, Variable variables with analogous names are generated automatically and       a dictionary is assembled that keeps track of this transformation.</li><li><code>f</code> - vector of drift coefficients for each state</li><li><code>σ</code> - diffusion matrix of the process</li><li><code>X</code> - basic semialgebraic set enclosing the state space of the process</li><li><code>iv</code> - independent variable of the process (usually time)</li><li><code>controls</code> - vector of control variables (empty if there are none)</li><li><code>poly_vars</code> - Dict mapping symbolic variables created by Catalyst.jl or ModelingToolkit.jl to generated Variable placeholders.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FHoltorf/MarkovBounds.jl/blob/8420eb38a796e1e331aea0a29d46a99dc414e0f0/src/processes.jl#L109-L124">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MarkovBounds.JumpDiffusionProcess" href="#MarkovBounds.JumpDiffusionProcess"><code>MarkovBounds.JumpDiffusionProcess</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">JumpDiffusionProcess(x, a, h, f, σ, X = FullSpace()
                     iv = _variable(&quot;t&quot;), controls = [], poly_vars = Dict())</code></pre><p>constructor returns <code>JumpDiffusionProcess</code> object with fields</p><ul><li><code>x</code> - vector containing the system state. Can be specified both as Variable type object       from DynamicPolynomials.jl or Num type object generated by Catalyst.jl/ModelingToolkit.jl.        In the latter case, Variable variables with analogous names are generated automatically and       a dictionary is assembled that keeps track of this transformation.</li><li><code>a</code> - vector containing the rate coefficients for each independent jump in the system</li><li><code>h</code> - vector of vectors containing the jump functions </li><li><code>f</code> - vector of drift coefficients for each state</li><li><code>σ</code> - diffusion matrix of the process</li><li><code>X</code> - basic semialgebraic set enclosing the state space of the process</li><li><code>iv</code> - independent variable of the process (usually time)</li><li><code>controls</code> - vector of control variables (empty if there are none)</li><li><code>poly_vars</code> - Dict mapping symbolic variables created by Catalyst.jl or ModelingToolkit.jl to generated Variable placeholders.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FHoltorf/MarkovBounds.jl/blob/8420eb38a796e1e331aea0a29d46a99dc414e0f0/src/processes.jl#L166-L183">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MarkovBounds.ControlProcess" href="#MarkovBounds.ControlProcess"><code>MarkovBounds.ControlProcess</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ControlProcess(MP::MarkovProcess, T::Real, U, obj, PCs = [], TCs = [], dis_fac = 0)</code></pre><p>constructor returns object of type <code>ControlProcess</code> with fields</p><ul><li><code>MP</code> - MarkovProcess to be controlled</li><li><code>T</code> - length of the time horizon (can be Inf)</li><li><code>U</code> - closed basic semialgebraic set describing admissible control actions</li><li><code>PathChanceConstraints</code> - Array of chance path constraints</li><li><code>TerminalChanceConstraints</code> - Array of terminal chance constraints</li><li><code>discount_factor</code> - discount factor for accumulating stage cost</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FHoltorf/MarkovBounds.jl/blob/8420eb38a796e1e331aea0a29d46a99dc414e0f0/src/processes.jl#L210-L220">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MarkovBounds.LagrangeMayer" href="#MarkovBounds.LagrangeMayer"><code>MarkovBounds.LagrangeMayer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LagrangeMayer</code></pre><p>a type used to specify an objective function consisting of a Lagrange and Mayer term, i.e., <span>$\mathbb{E}\left[ \int_{0}^T l(x(t), u(t)) \, dt + m(x(T))\right]$</span>. The Lagrange and Mayer term are specified in terms of polynomial functions <span>$l : X \times U \to \mathbb{R}$</span> and <span>$m : X \to \mathbb{R}$</span>, respectively.</p><p>Fields: </p><ul><li><code>l</code> - <code>AbstractPolynomialLike</code> determining the Lagrange term</li><li><code>m</code> - <code>AbstractPolynomialLike</code> determining the Mayer term</li></ul><p>If only a Lagrange or Mayer term is neede for specification of the objective function, one can make use of the functions <code>Lagrange(l::AbstractPolynomialLike)</code> and <code>Mayer(m::AbstractPolynomialLike)</code> for more convenient model specification.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FHoltorf/MarkovBounds.jl/blob/8420eb38a796e1e331aea0a29d46a99dc414e0f0/src/processes.jl#L267-L280">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MarkovBounds.TerminalSetProbability" href="#MarkovBounds.TerminalSetProbability"><code>MarkovBounds.TerminalSetProbability</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TerminalSetProbability</code></pre><p>a type used to specify an objective function quantifiying the probability for a supported Markov process  to occupy a specified closed basic semialgebraic set at the end of the control horizon specified in a <code>ControlProcess</code> object. </p><p>Fields: </p><ul><li>X - basic semialgebraic set whose occupation probability is to be quantified at the end of the control horizon</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FHoltorf/MarkovBounds.jl/blob/8420eb38a796e1e331aea0a29d46a99dc414e0f0/src/processes.jl#L254-L262">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MarkovBounds.ExitProbability" href="#MarkovBounds.ExitProbability"><code>MarkovBounds.ExitProbability</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ExitProbability</code></pre><p>a type used to specify an objective function quantifiying the probability for a supported Markov process  to exit a specified closed basic semialgebraic set on the time horizon specified in a <code>ControlProcess</code> object. </p><p>Fields: </p><ul><li>X - basic semialgebraic set whose exit probability is to be quantified</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FHoltorf/MarkovBounds.jl/blob/8420eb38a796e1e331aea0a29d46a99dc414e0f0/src/processes.jl#L240-L248">source</a></section></article><h2 id="Bounds-on-Stationary-Moments-of-Markov-Processes"><a class="docs-heading-anchor" href="#Bounds-on-Stationary-Moments-of-Markov-Processes">Bounds on Stationary Moments of Markov Processes</a><a id="Bounds-on-Stationary-Moments-of-Markov-Processes-1"></a><a class="docs-heading-anchor-permalink" href="#Bounds-on-Stationary-Moments-of-Markov-Processes" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MarkovBounds.stationary_polynomial-Tuple{MarkovProcess, AbstractPolynomialLike, Int64, Any}" href="#MarkovBounds.stationary_polynomial-Tuple{MarkovProcess, AbstractPolynomialLike, Int64, Any}"><code>MarkovBounds.stationary_polynomial</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">stationary_polynomial(MP::MarkovProcess, v::APL, d::Int, solver)</code></pre><p>returns a <strong>lower</strong> bound on the expecation of a polynomial observables <span>$v(x)$</span> at steady state of the Markov process <code>MP</code>. The bound is computed based on an SOS program over a polynomial of degree at most <code>d</code>; the bounds can be tightened by increasing <code>d</code>. The program is solved with <code>solver</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FHoltorf/MarkovBounds.jl/blob/8420eb38a796e1e331aea0a29d46a99dc414e0f0/src/sos_programs_stationary.jl#L31-L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MarkovBounds.stationary_mean-Tuple{MarkovProcess, AbstractPolynomialLike, Int64, Any}" href="#MarkovBounds.stationary_mean-Tuple{MarkovProcess, AbstractPolynomialLike, Int64, Any}"><code>MarkovBounds.stationary_mean</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">stationary_mean(MP::MarkovProcess, v::APL, d::Int, solver)</code></pre><p>returns <strong>lower</strong> and <strong>upper</strong> bound on the observable <span>$v(x)$</span> at steady state of the Markov process <code>MP</code>. Bounds are computed based on SOS programs over a polynomial of degree at most <code>d</code>; the bounds can be tightened by increasing <code>d</code>. The program is solved with <code>solver</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FHoltorf/MarkovBounds.jl/blob/8420eb38a796e1e331aea0a29d46a99dc414e0f0/src/sos_programs_stationary.jl#L49-L56">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MarkovBounds.stationary_mean" href="#MarkovBounds.stationary_mean"><code>MarkovBounds.stationary_mean</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">stationary_mean(rn::ReactionSystem, S0::Dict, S, d::Int, solver,
		scales = Dict(s =&gt; 1 for s in species(rn));
		auto_scaling = false)</code></pre><p>returns <strong>lower</strong> and <strong>upper</strong> bound on the mean of species <code>S</code> of the reaction network <code>rn</code> with initial condition <code>S0</code> (for all species!). The bound is based on an SOS program of order <code>d</code> solved via <code>solver</code>; the bounds can be tightened by increasing <code>d</code>.</p><p>For numerical stability, it is recommended to provide scales of the expected magnitude of molecular counts for the different species at steady state. If the system is <strong>closed</strong> it is also possible to enable auto_scaling which will find the maximum molecular counts for each species under stoichiometry constraints (via LP).</p><p>If the initial condition of the reaction network under investigation is unknown or irrelevant, simply call</p><pre><code class="nohighlight hljs">stationary_mean(rn::ReactionSystem, S, d::Int, solver,
		scales = Dict(s =&gt; 1 for s in species(rn))).</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FHoltorf/MarkovBounds.jl/blob/8420eb38a796e1e331aea0a29d46a99dc414e0f0/src/sos_programs_stationary.jl#L68-L89">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MarkovBounds.stationary_variance-Tuple{MarkovProcess, AbstractPolynomialLike, Int64, Any}" href="#MarkovBounds.stationary_variance-Tuple{MarkovProcess, AbstractPolynomialLike, Int64, Any}"><code>MarkovBounds.stationary_variance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">stationary_variance(MP::MarkovProcess, v::APL, d::Int, solver)</code></pre><p>returns SOS program of degree <code>d</code> for computation of an <strong>upper</strong> bound on the variance of a polynomial observables <code>v</code> at steady state of the Markov process <code>MP</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FHoltorf/MarkovBounds.jl/blob/8420eb38a796e1e331aea0a29d46a99dc414e0f0/src/sos_programs_stationary.jl#L105-L111">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MarkovBounds.stationary_variance" href="#MarkovBounds.stationary_variance"><code>MarkovBounds.stationary_variance</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">stationary_variance(rn::ReactionSystem, S0, x, d::Int, solver,
		    scales = Dict(s =&gt; 1 for s in species(rn));
		    auto_scaling = false)</code></pre><p>returns <strong>upper</strong> bound on the variance of species <code>S</code> of the reaction network rn with initial condition <code>S0</code> (for all species!). The bound is based on an SOS program of degree <code>d</code> solved via <code>solver</code>; the bound can be tightened by increasing <code>d</code>.</p><p>For numerical stability, it is recommended to provide scales of the expected magnitude of molecular counts for the different species at steady state. If the system is <strong>closed</strong> it is also possible to enable <code>auto_scaling</code> which will find the maximum molecular counts for each species under stoichiometry constraints (via LP).</p><p>If the initial condition of the reaction network under investigation is unknown or irrelevant, simply call</p><pre><code class="nohighlight hljs">stationary_variance(rn::ReactionSystem, S, d::Int, solver,
		    scales = Dict(s =&gt; 1 for s in species(rn)))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FHoltorf/MarkovBounds.jl/blob/8420eb38a796e1e331aea0a29d46a99dc414e0f0/src/sos_programs_stationary.jl#L138-L159">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MarkovBounds.stationary_covariance_ellipsoid-Tuple{MarkovProcess, Vector{&lt;:AbstractPolynomialLike}, Int64, Any}" href="#MarkovBounds.stationary_covariance_ellipsoid-Tuple{MarkovProcess, Vector{&lt;:AbstractPolynomialLike}, Int64, Any}"><code>MarkovBounds.stationary_covariance_ellipsoid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">stationary_covariance_ellipsoid(MP::MarkovProcess, v::Vector{&lt;:APL}, d::Int, solver)</code></pre><p>returns an <strong>upper</strong> on the volume of the covariance ellipsoid of a vector of polynomial observables <span>$v(x)$</span>, i.e., <span>$\text{det}(\mathbb{E} [v(x)v(x)^\top] - \mathbb{E}[v(x)] \mathbb{E}[v(x)]^\top)$</span>, at steady state of the Markov process <code>MP</code>. The bounds are computed via an SOS program of degree <code>d</code>, hence can be tightened by increasing <code>d</code>. This computation requires a <code>solver</code> that can handle exponential cone constraints.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FHoltorf/MarkovBounds.jl/blob/8420eb38a796e1e331aea0a29d46a99dc414e0f0/src/sos_programs_stationary.jl#L174-L183">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MarkovBounds.stationary_covariance_ellipsoid" href="#MarkovBounds.stationary_covariance_ellipsoid"><code>MarkovBounds.stationary_covariance_ellipsoid</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">stationary_covariance_ellipsoid(rn::ReactionSystem, S0::Dict, S::AbstractVector, d::Int, solver,
				scales = Dict(s =&gt; 1 for s in species(rn));
				auto_scaling = false)</code></pre><p>returns an <strong>upper</strong> on the volume of the covariance ellipsoid of any subset <code>S</code> of the chemical species in the reaction network <code>rn</code>, i.e., <span>$\text{det}(\mathbb{E}[SS^\top] - \mathbb{E}[S] \mathbb{E}[S]^\top)$</span>, at steady state of the associated jump process. The reaction network is assumed to have the deterministic initial state <code>S0</code> (all species must be included here!). The bounds are computed via an SOS program of degree <code>d</code>, hence can be tightened by increasing <code>d</code>. This computation requires a solver that can deal with exponential cone constraints.</p><p>For numerical stability, it is recommended to provide scales of the expected magnitude of molecular counts for the different species at steady state. If the system is <strong>closed</strong> it is also possible to enable auto_scaling which will find the maximum molecular counts for each species under stoichiometry constraints (via LP).</p><p>If the initial condition of the reaction network under investigation is unknown or irrelevant, simply call</p><pre><code class="nohighlight hljs">stationary_covariance_ellipsoid(rn::ReactionSystem, S, d::Int, solver,
				scales = Dict(s =&gt; 1 for s in species(rn)))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FHoltorf/MarkovBounds.jl/blob/8420eb38a796e1e331aea0a29d46a99dc414e0f0/src/sos_programs_stationary.jl#L218-L242">source</a></section></article><h2 id="Bounds-on-Transient-Moments-of-Markov-Processes"><a class="docs-heading-anchor" href="#Bounds-on-Transient-Moments-of-Markov-Processes">Bounds on Transient Moments of Markov Processes</a><a id="Bounds-on-Transient-Moments-of-Markov-Processes-1"></a><a class="docs-heading-anchor-permalink" href="#Bounds-on-Transient-Moments-of-Markov-Processes" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MarkovBounds.transient_polynomial-Tuple{MarkovProcess, Dict, AbstractPolynomialLike, Int64, AbstractVector{&lt;:Real}, Any}" href="#MarkovBounds.transient_polynomial-Tuple{MarkovProcess, Dict, AbstractPolynomialLike, Int64, AbstractVector{&lt;:Real}, Any}"><code>MarkovBounds.transient_polynomial</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transient_polynomial(MP::MarkovProcess, μ0::Dict, v::APL, d::Int, trange::AbstractVector{&lt;:Real}, solver)</code></pre><p>returns a <strong>lower</strong> bound on <span>$\mathbb{E}[v(x(T))]$</span> where <span>$v$</span> is a polynomial and <span>$x(T)$</span> the state of the Markov process <code>MP</code> at time <code>T = trange[end]</code>. <code>μ0</code> encodes the distribution of the initial state of the process in terms of its moments; specifically, it maps monomials to the respective moments of the initial distribution. <code>trange</code> is an <strong>ordered</strong> collection of time points used to discretize the time horizon <span>$[0,T]$</span>, i.e., <code>T = trange[end]</code>. Populating <code>trange</code> and increasing <code>d</code> improves the computed bound.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FHoltorf/MarkovBounds.jl/blob/8420eb38a796e1e331aea0a29d46a99dc414e0f0/src/sos_programs_transient.jl#L54-L64">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MarkovBounds.transient_mean-Tuple{MarkovProcess, Dict, AbstractPolynomialLike, Int64, AbstractVector{&lt;:Real}, Any}" href="#MarkovBounds.transient_mean-Tuple{MarkovProcess, Dict, AbstractPolynomialLike, Int64, AbstractVector{&lt;:Real}, Any}"><code>MarkovBounds.transient_mean</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transient_mean(MP::MarkovProcess, μ0::Dict, x::APL, d::Int, trange::AbstractVector{&lt;:Real}, solver)</code></pre><p>returns a <strong>lower</strong> and <strong>upper</strong> bound on <span>$\mathbb{E}[v(x(T))]$</span> where <span>$v$</span> is a polynomial and <span>$x(T)$</span> the state of the Markov process <code>MP</code> at time <code>T = trange[end]</code>. <code>μ0</code> encodes the distribution of the initial state of the process in terms of its moments; specifically, it maps monomials to the respective moments of the initial distribution. trange is an <strong>ordered</strong> collection of time points used to discretize the time horizon <span>$[0,T]$</span>, i.e., <code>T = trange[end]</code>. Populating <code>trange</code> and increasing <code>d</code> improves the computed bounds.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FHoltorf/MarkovBounds.jl/blob/8420eb38a796e1e331aea0a29d46a99dc414e0f0/src/sos_programs_transient.jl#L80-L90">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MarkovBounds.transient_mean" href="#MarkovBounds.transient_mean"><code>MarkovBounds.transient_mean</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">transient_mean(rn::ReactionSystem, S0::Dict, S, d::Int, trange::AbstractVector{&lt;:Number}, solver,
		scales = Dict(s =&gt; 1 for s in species(rn));
		auto_scaling = false)</code></pre><p>returns a <strong>lower</strong> and <strong>upper</strong> bound on the mean of the molecular count of species <code>S</code> in reaction network <code>rn</code> at time <code>T = trange[end]</code>. <code>S0</code> refers to the <strong>deterministic</strong> initial state of the reaction system (including all species!). <code>trange</code> is an <strong>ordered</strong> collection of time points used to discretize the time horizon <span>$[0,T]$</span>, i.e., <code>T = trange[end]</code>. Populating trange and increasing <code>d</code> improves the computed bounds.</p><p>For numerical stability, it is recommended to provide scales of the expected magnitude of molecular counts for the different species at steady state. If the system is <strong>closed</strong> it is also possible to enable auto_scaling which will find the maximum molecular counts for each species under stoichiometry constraints (via LP).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FHoltorf/MarkovBounds.jl/blob/8420eb38a796e1e331aea0a29d46a99dc414e0f0/src/sos_programs_transient.jl#L107-L124">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MarkovBounds.transient_variance-Tuple{MarkovProcess, Dict, AbstractPolynomialLike, Int64, AbstractVector{&lt;:Real}, Any}" href="#MarkovBounds.transient_variance-Tuple{MarkovProcess, Dict, AbstractPolynomialLike, Int64, AbstractVector{&lt;:Real}, Any}"><code>MarkovBounds.transient_variance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transient_variance(MP::MarkovProcess, μ0::Dict, v::APL, d::Int, trange::AbstractVector{&lt;:Real}, solver)</code></pre><p>returns an <strong>upper</strong> bound on <span>$\mathbb{E}[v(x(T))^2] - \mathbb{E}[v(x(T))]^2$</span> where <span>$v$</span> is a polynomial and <span>$x(T)$</span> the state of the Markov process <code>MP</code> at time <code>T = trange[end]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FHoltorf/MarkovBounds.jl/blob/8420eb38a796e1e331aea0a29d46a99dc414e0f0/src/sos_programs_transient.jl#L134-L139">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MarkovBounds.transient_variance" href="#MarkovBounds.transient_variance"><code>MarkovBounds.transient_variance</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">transient_variance(rn::ReactionSystem, S0::Dict, S, d::Int, trange::AbstractVector{&lt;:Real}, solver,
		    scales = Dict(s =&gt; 1 for s in species(rn));
			auto_scaling = false)</code></pre><p>returns an <strong>upper</strong> bound on the variance of species <code>S</code> in the reaction network <code>rn</code> at time <code>T = trange[end]</code>. <code>S0</code> refers to the <strong>deterministic</strong> initial state of the reaction system (including all species!). <code>trange</code> is an <strong>ordered</strong> collection of time points used to discretize the time horizon <span>$[0,T]$</span>, i.e., <code>T = trange[end]</code>. Populating <code>trange</code> and increasing <code>d</code> improves the computed bounds.</p><p>For numerical stability, it is recommended to provide scales of the expected magnitude of molecular counts for the different species at steady state. If the system is <strong>closed</strong> it is also possible to enable <code>auto_scaling</code> which will find the maximum molecular counts for each species under stoichiometry constraints (via LP).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FHoltorf/MarkovBounds.jl/blob/8420eb38a796e1e331aea0a29d46a99dc414e0f0/src/sos_programs_transient.jl#L182-L199">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MarkovBounds.transient_covariance_ellipsoid-Tuple{MarkovProcess, Dict, Vector{AbstractPolynomialLike}, Int64, AbstractVector{&lt;:Real}, Any}" href="#MarkovBounds.transient_covariance_ellipsoid-Tuple{MarkovProcess, Dict, Vector{AbstractPolynomialLike}, Int64, AbstractVector{&lt;:Real}, Any}"><code>MarkovBounds.transient_covariance_ellipsoid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transient_covariance_ellipsoid(MP::MarkovProcess, μ0::Dict, v::Vector{APL}, d::Int, trange::AbstractVector{&lt;:Real}, solver)</code></pre><p>returns an <strong>upper</strong> bound on the volume of the covariance ellipsoid <span>$\text{det}(\mathbb{E}[v(x(T))v(x(T))^\top] - \mathbb{E}[v(x(T))] \mathbb{E}[v(x(T))]^\top)$</span>, where <span>$v$</span> is a polynomial and <span>$x(T)$</span> the state of the Markov process <code>MP</code> at time <code>T = trange[end]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FHoltorf/MarkovBounds.jl/blob/8420eb38a796e1e331aea0a29d46a99dc414e0f0/src/sos_programs_transient.jl#L208-L213">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MarkovBounds.transient_covariance_ellipsoid" href="#MarkovBounds.transient_covariance_ellipsoid"><code>MarkovBounds.transient_covariance_ellipsoid</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">transient_covariance_ellipsoid(rn::ReactionSystem, S0::Dict, S::AbstractVector, d::Int, trange::AbstractVector{&lt;:Real}, solver,
						scales = Dict(s =&gt; 1 for s in species(rn));
						auto_scaling = false)</code></pre><p>returns an <strong>upper</strong> bound on the volume of the covariance ellipsoid associated with any collection of chemical species in the reaction network <code>rn</code> at time <code>T = trange[end]</code>. S0 refers to the <strong>deterministic</strong> initial state of the reaction system (including all species!). <code>trange</code> is an <strong>ordered</strong> collection of time points used to discretize the time horizon <span>$[0,T]$</span>, i.e., <code>T = trange[end]</code>. Populating <code>trange</code> and increasing <code>d</code> improves the computed bounds.</p><p>For numerical stability, it is recommended to provide scales of the expected magnitude of molecular counts for the different species at steady state. If the system is <strong>closed</strong> it is also possible to enable auto_scaling which will find the maximum molecular counts for each species under stoichiometry constraints (via LP).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FHoltorf/MarkovBounds.jl/blob/8420eb38a796e1e331aea0a29d46a99dc414e0f0/src/sos_programs_transient.jl#L264-L281">source</a></section></article><h2 id="Bounds-on-Stochastic-Optimal-Control-Problems"><a class="docs-heading-anchor" href="#Bounds-on-Stochastic-Optimal-Control-Problems">Bounds on Stochastic Optimal Control Problems</a><a id="Bounds-on-Stochastic-Optimal-Control-Problems-1"></a><a class="docs-heading-anchor-permalink" href="#Bounds-on-Stochastic-Optimal-Control-Problems" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MarkovBounds.optimal_control-Tuple{ControlProcess, Dict, Int64, AbstractVector{&lt;:Real}, Any}" href="#MarkovBounds.optimal_control-Tuple{ControlProcess, Dict, Int64, AbstractVector{&lt;:Real}, Any}"><code>MarkovBounds.optimal_control</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">optimal_control(CP::ControlProcess, μ0::Dict, d::Int, trange::AbstractVector{&lt;:Real}, solver)</code></pre><p>returns a <strong>lower</strong> bound on the objective value of the (stochastic) optimal control problem specified by CP. <code>μ0</code> encodes information about the distribution of the initial state of the process; specifically, <code>μ0</code> maps a given monomial to the corresponding moment of the initial distribution. trange refers to an <em>ordered</em> set of time points discretizing the control horizon. trange[end] should coincide with the end of the control horizon, i.e., <code>trange[end] = Inf</code> in case of an infinite horizon problem. The bound is computed via a SOS program of degree d solved with an appropriate method given by solver.</p><p>The bound can be tightened by populating trange or increasing <code>d</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FHoltorf/MarkovBounds.jl/blob/8420eb38a796e1e331aea0a29d46a99dc414e0f0/src/sos_programs_control.jl#L3-L16">source</a></section></article><h2 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MarkovBounds.reaction_process_setup-Tuple{Catalyst.ReactionSystem, Dict}" href="#MarkovBounds.reaction_process_setup-Tuple{Catalyst.ReactionSystem, Dict}"><code>MarkovBounds.reaction_process_setup</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reaction_process_setup(rn::ReactionSystem, x0::Dict;
                scales = Dict(s =&gt; 1.0 for s in species(rn)),
                auto_scaling = false, solver = nothing)

transforms a reaction network as defined by Catalyst.jl&#39;s ReactionSystem type
into an equivalent ReactionProcess accounting for reaction invariants and
scales.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FHoltorf/MarkovBounds.jl/blob/8420eb38a796e1e331aea0a29d46a99dc414e0f0/src/utils.jl#L51-L59">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MarkovBounds.approximate_stationary_measure" href="#MarkovBounds.approximate_stationary_measure"><code>MarkovBounds.approximate_stationary_measure</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">approximate_stationary_measure(MP::MarkovProcess, v::APL, order::Int, solver, P::Partition;
                               side_infos::BasicSemialgebraicSet)</code></pre><p>returns approximate values for the stationary measure on the partition <code>P</code>.  <code>v</code> is a polynomial observable whose expectation is minimized when determining the approximation.  The choice of <code>v</code> shall be understood as means to regularize the problem. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FHoltorf/MarkovBounds.jl/blob/8420eb38a796e1e331aea0a29d46a99dc414e0f0/src/sos_programs_stationary.jl#L318-L325">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MarkovBounds.max_entropy_measure" href="#MarkovBounds.max_entropy_measure"><code>MarkovBounds.max_entropy_measure</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">max_entropy_measure(MP::MarkovProcess, order::Int, solver, P::Partition;
                               side_infos::BasicSemialgebraicSet)</code></pre><p>returns approximate values for the stationary measure which maximizes the entropy on the partition <code>P</code>.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FHoltorf/MarkovBounds.jl/blob/8420eb38a796e1e331aea0a29d46a99dc414e0f0/src/sos_programs_stationary.jl#L376-L381">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MarkovBounds.stationary_covariance_ellipsoid" href="#MarkovBounds.stationary_covariance_ellipsoid"><code>MarkovBounds.stationary_covariance_ellipsoid</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">stationary_covariance_ellipsoid(MP::MarkovProcess, v::Vector{&lt;:APL}, d::Int, solver)</code></pre><p>returns an <strong>upper</strong> on the volume of the covariance ellipsoid of a vector of polynomial observables <span>$v(x)$</span>, i.e., <span>$\text{det}(\mathbb{E} [v(x)v(x)^\top] - \mathbb{E}[v(x)] \mathbb{E}[v(x)]^\top)$</span>, at steady state of the Markov process <code>MP</code>. The bounds are computed via an SOS program of degree <code>d</code>, hence can be tightened by increasing <code>d</code>. This computation requires a <code>solver</code> that can handle exponential cone constraints.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FHoltorf/MarkovBounds.jl/blob/8420eb38a796e1e331aea0a29d46a99dc414e0f0/src/sos_programs_stationary.jl#L174-L183">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MarkovBounds.stationary_mean" href="#MarkovBounds.stationary_mean"><code>MarkovBounds.stationary_mean</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">stationary_mean(MP::MarkovProcess, v::APL, d::Int, solver)</code></pre><p>returns <strong>lower</strong> and <strong>upper</strong> bound on the observable <span>$v(x)$</span> at steady state of the Markov process <code>MP</code>. Bounds are computed based on SOS programs over a polynomial of degree at most <code>d</code>; the bounds can be tightened by increasing <code>d</code>. The program is solved with <code>solver</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FHoltorf/MarkovBounds.jl/blob/8420eb38a796e1e331aea0a29d46a99dc414e0f0/src/sos_programs_stationary.jl#L49-L56">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MarkovBounds.stationary_polynomial" href="#MarkovBounds.stationary_polynomial"><code>MarkovBounds.stationary_polynomial</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">stationary_polynomial(MP::MarkovProcess, v::APL, d::Int, solver)</code></pre><p>returns a <strong>lower</strong> bound on the expecation of a polynomial observables <span>$v(x)$</span> at steady state of the Markov process <code>MP</code>. The bound is computed based on an SOS program over a polynomial of degree at most <code>d</code>; the bounds can be tightened by increasing <code>d</code>. The program is solved with <code>solver</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FHoltorf/MarkovBounds.jl/blob/8420eb38a796e1e331aea0a29d46a99dc414e0f0/src/sos_programs_stationary.jl#L31-L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MarkovBounds.stationary_pop" href="#MarkovBounds.stationary_pop"><code>MarkovBounds.stationary_pop</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">stationary_pop(MP::MarkovProcess, v::APL, d::Int, solver)</code></pre><p>returns SOS program of degree <code>d</code> for compuitation of a <strong>lower</strong> bound on the expecation of a polynomial observable <span>$v(x)$</span> at steady state of the Markov process <code>MP</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FHoltorf/MarkovBounds.jl/blob/8420eb38a796e1e331aea0a29d46a99dc414e0f0/src/sos_programs_stationary.jl#L6-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MarkovBounds.stationary_probability_mass-Tuple{MarkovProcess, BasicSemialgebraicSet, Int64, Any}" href="#MarkovBounds.stationary_probability_mass-Tuple{MarkovProcess, BasicSemialgebraicSet, Int64, Any}"><code>MarkovBounds.stationary_probability_mass</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">stationary_probability_mass(MP::MarkovProcess, X::BasicSemialgebraicSet, d::Int,
						solver)</code></pre><p>returns <strong>lower</strong> and <strong>upper</strong> bounds on the probability mass associated with the set <code>X</code>. <code>d</code> refers to the order of the relaxation used, again the bounds will tighten monotonically with increasing order. solver refers to the optimizer used to solve the semidefinite programs which optimal values furnish the bounds. This is the weakest formulation that can be used to compute bounds on the probabiltiy mass associated with a Basic semialgebraic set. For sensible results the set <code>X</code> should have non- empty interior. In order to improve the bounds the user should supply a carefully defined  partition of the state space. In that case it is most sensible to choose <code>X</code> as a subset of the element  of said partition. Then, one should call</p><pre><code class="nohighlight hljs">stationary_probability_mass(MP::MarkovProcess, v::Int, order::Int, solver,
                             P::Partition)</code></pre><p>where <code>v</code> refers to the vertex of the partition graph that corresponds to the set <code>X</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FHoltorf/MarkovBounds.jl/blob/8420eb38a796e1e331aea0a29d46a99dc414e0f0/src/sos_programs_stationary.jl#L257-L274">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MarkovBounds.stationary_variance" href="#MarkovBounds.stationary_variance"><code>MarkovBounds.stationary_variance</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">stationary_variance(MP::MarkovProcess, v::APL, d::Int, solver)</code></pre><p>returns SOS program of degree <code>d</code> for computation of an <strong>upper</strong> bound on the variance of a polynomial observables <code>v</code> at steady state of the Markov process <code>MP</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FHoltorf/MarkovBounds.jl/blob/8420eb38a796e1e331aea0a29d46a99dc414e0f0/src/sos_programs_stationary.jl#L105-L111">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MarkovBounds.max_entropy_measure-Tuple{MarkovProcess, Dict, Int64, AbstractVector{&lt;:Real}, Any, Partition}" href="#MarkovBounds.max_entropy_measure-Tuple{MarkovProcess, Dict, Int64, AbstractVector{&lt;:Real}, Any, Partition}"><code>MarkovBounds.max_entropy_measure</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">max_entropy_measure(MP::MarkovProcess, μ0::Dict, d::Int, trange::AbstractVector{&lt;:Real}, solver, P::Partition;
                    side_infos::BasicSemialgebraicSet)</code></pre><p>returns approximate values for the transient measure which maximizes the entropy on the partition <code>P</code> at time t.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FHoltorf/MarkovBounds.jl/blob/8420eb38a796e1e331aea0a29d46a99dc414e0f0/src/sos_programs_transient.jl#L373-L378">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MarkovBounds.transient_covariance_ellipsoid" href="#MarkovBounds.transient_covariance_ellipsoid"><code>MarkovBounds.transient_covariance_ellipsoid</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">transient_covariance_ellipsoid(rn::ReactionSystem, S0::Dict, S::AbstractVector, d::Int, trange::AbstractVector{&lt;:Real}, solver,
						scales = Dict(s =&gt; 1 for s in species(rn));
						auto_scaling = false)</code></pre><p>returns an <strong>upper</strong> bound on the volume of the covariance ellipsoid associated with any collection of chemical species in the reaction network <code>rn</code> at time <code>T = trange[end]</code>. S0 refers to the <strong>deterministic</strong> initial state of the reaction system (including all species!). <code>trange</code> is an <strong>ordered</strong> collection of time points used to discretize the time horizon <span>$[0,T]$</span>, i.e., <code>T = trange[end]</code>. Populating <code>trange</code> and increasing <code>d</code> improves the computed bounds.</p><p>For numerical stability, it is recommended to provide scales of the expected magnitude of molecular counts for the different species at steady state. If the system is <strong>closed</strong> it is also possible to enable auto_scaling which will find the maximum molecular counts for each species under stoichiometry constraints (via LP).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FHoltorf/MarkovBounds.jl/blob/8420eb38a796e1e331aea0a29d46a99dc414e0f0/src/sos_programs_transient.jl#L264-L281">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MarkovBounds.transient_covariance_ellipsoid" href="#MarkovBounds.transient_covariance_ellipsoid"><code>MarkovBounds.transient_covariance_ellipsoid</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">transient_covariance_ellipsoid(MP::MarkovProcess, μ0::Dict, v::Vector{APL}, d::Int, trange::AbstractVector{&lt;:Real}, solver)</code></pre><p>returns an <strong>upper</strong> bound on the volume of the covariance ellipsoid <span>$\text{det}(\mathbb{E}[v(x(T))v(x(T))^\top] - \mathbb{E}[v(x(T))] \mathbb{E}[v(x(T))]^\top)$</span>, where <span>$v$</span> is a polynomial and <span>$x(T)$</span> the state of the Markov process <code>MP</code> at time <code>T = trange[end]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FHoltorf/MarkovBounds.jl/blob/8420eb38a796e1e331aea0a29d46a99dc414e0f0/src/sos_programs_transient.jl#L208-L213">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MarkovBounds.transient_mean" href="#MarkovBounds.transient_mean"><code>MarkovBounds.transient_mean</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">transient_mean(MP::MarkovProcess, μ0::Dict, x::APL, d::Int, trange::AbstractVector{&lt;:Real}, solver)</code></pre><p>returns a <strong>lower</strong> and <strong>upper</strong> bound on <span>$\mathbb{E}[v(x(T))]$</span> where <span>$v$</span> is a polynomial and <span>$x(T)$</span> the state of the Markov process <code>MP</code> at time <code>T = trange[end]</code>. <code>μ0</code> encodes the distribution of the initial state of the process in terms of its moments; specifically, it maps monomials to the respective moments of the initial distribution. trange is an <strong>ordered</strong> collection of time points used to discretize the time horizon <span>$[0,T]$</span>, i.e., <code>T = trange[end]</code>. Populating <code>trange</code> and increasing <code>d</code> improves the computed bounds.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FHoltorf/MarkovBounds.jl/blob/8420eb38a796e1e331aea0a29d46a99dc414e0f0/src/sos_programs_transient.jl#L80-L90">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MarkovBounds.transient_mean" href="#MarkovBounds.transient_mean"><code>MarkovBounds.transient_mean</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">transient_mean(rn::ReactionSystem, S0::Dict, S, d::Int, trange::AbstractVector{&lt;:Number}, solver,
		scales = Dict(s =&gt; 1 for s in species(rn));
		auto_scaling = false)</code></pre><p>returns a <strong>lower</strong> and <strong>upper</strong> bound on the mean of the molecular count of species <code>S</code> in reaction network <code>rn</code> at time <code>T = trange[end]</code>. <code>S0</code> refers to the <strong>deterministic</strong> initial state of the reaction system (including all species!). <code>trange</code> is an <strong>ordered</strong> collection of time points used to discretize the time horizon <span>$[0,T]$</span>, i.e., <code>T = trange[end]</code>. Populating trange and increasing <code>d</code> improves the computed bounds.</p><p>For numerical stability, it is recommended to provide scales of the expected magnitude of molecular counts for the different species at steady state. If the system is <strong>closed</strong> it is also possible to enable auto_scaling which will find the maximum molecular counts for each species under stoichiometry constraints (via LP).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FHoltorf/MarkovBounds.jl/blob/8420eb38a796e1e331aea0a29d46a99dc414e0f0/src/sos_programs_transient.jl#L107-L124">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MarkovBounds.transient_polynomial" href="#MarkovBounds.transient_polynomial"><code>MarkovBounds.transient_polynomial</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">transient_polynomial(MP::MarkovProcess, μ0::Dict, v::APL, d::Int, trange::AbstractVector{&lt;:Real}, solver)</code></pre><p>returns a <strong>lower</strong> bound on <span>$\mathbb{E}[v(x(T))]$</span> where <span>$v$</span> is a polynomial and <span>$x(T)$</span> the state of the Markov process <code>MP</code> at time <code>T = trange[end]</code>. <code>μ0</code> encodes the distribution of the initial state of the process in terms of its moments; specifically, it maps monomials to the respective moments of the initial distribution. <code>trange</code> is an <strong>ordered</strong> collection of time points used to discretize the time horizon <span>$[0,T]$</span>, i.e., <code>T = trange[end]</code>. Populating <code>trange</code> and increasing <code>d</code> improves the computed bound.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FHoltorf/MarkovBounds.jl/blob/8420eb38a796e1e331aea0a29d46a99dc414e0f0/src/sos_programs_transient.jl#L54-L64">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MarkovBounds.transient_pop" href="#MarkovBounds.transient_pop"><code>MarkovBounds.transient_pop</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">transient_pop(MP::MarkovProcess, μ0::Dict, v::APL, d::Int, trange::AbstractVector{&lt;:Real}, solver)</code></pre><p>returns SOS program of degree <code>d</code> for computing a <strong>lower</strong> bound on <span>$\mathbb{E}[v(x(T))]$</span> where <span>$v$</span> is a polynomial and <span>$x(T)$</span> the state of the Markov process <code>MP</code> at time <code>T = trange[end]</code>. μ0 encodes the distribution of the initial state of the process in terms of its moments; specifically, it maps monomials to the respective moments of the initial distribution. <code>trange</code> is an <strong>ordered</strong> collection of time points used to discretize the time horizon <span>$[0,T]$</span>, i.e., <code>T = trange[end]</code>. Populating <code>trange</code> and increasing <code>d</code> has a tightening effect on the bound furnished by the assembled SOS program.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FHoltorf/MarkovBounds.jl/blob/8420eb38a796e1e331aea0a29d46a99dc414e0f0/src/sos_programs_transient.jl#L3-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MarkovBounds.transient_variance" href="#MarkovBounds.transient_variance"><code>MarkovBounds.transient_variance</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">transient_variance(rn::ReactionSystem, S0::Dict, S, d::Int, trange::AbstractVector{&lt;:Real}, solver,
		    scales = Dict(s =&gt; 1 for s in species(rn));
			auto_scaling = false)</code></pre><p>returns an <strong>upper</strong> bound on the variance of species <code>S</code> in the reaction network <code>rn</code> at time <code>T = trange[end]</code>. <code>S0</code> refers to the <strong>deterministic</strong> initial state of the reaction system (including all species!). <code>trange</code> is an <strong>ordered</strong> collection of time points used to discretize the time horizon <span>$[0,T]$</span>, i.e., <code>T = trange[end]</code>. Populating <code>trange</code> and increasing <code>d</code> improves the computed bounds.</p><p>For numerical stability, it is recommended to provide scales of the expected magnitude of molecular counts for the different species at steady state. If the system is <strong>closed</strong> it is also possible to enable <code>auto_scaling</code> which will find the maximum molecular counts for each species under stoichiometry constraints (via LP).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FHoltorf/MarkovBounds.jl/blob/8420eb38a796e1e331aea0a29d46a99dc414e0f0/src/sos_programs_transient.jl#L182-L199">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MarkovBounds.transient_variance" href="#MarkovBounds.transient_variance"><code>MarkovBounds.transient_variance</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">transient_variance(MP::MarkovProcess, μ0::Dict, v::APL, d::Int, trange::AbstractVector{&lt;:Real}, solver)</code></pre><p>returns an <strong>upper</strong> bound on <span>$\mathbb{E}[v(x(T))^2] - \mathbb{E}[v(x(T))]^2$</span> where <span>$v$</span> is a polynomial and <span>$x(T)$</span> the state of the Markov process <code>MP</code> at time <code>T = trange[end]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FHoltorf/MarkovBounds.jl/blob/8420eb38a796e1e331aea0a29d46a99dc414e0f0/src/sos_programs_transient.jl#L134-L139">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MarkovBounds.optimal_control" href="#MarkovBounds.optimal_control"><code>MarkovBounds.optimal_control</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">optimal_control(CP::ControlProcess, μ0::Dict, d::Int, trange::AbstractVector{&lt;:Real}, solver)</code></pre><p>returns a <strong>lower</strong> bound on the objective value of the (stochastic) optimal control problem specified by CP. <code>μ0</code> encodes information about the distribution of the initial state of the process; specifically, <code>μ0</code> maps a given monomial to the corresponding moment of the initial distribution. trange refers to an <em>ordered</em> set of time points discretizing the control horizon. trange[end] should coincide with the end of the control horizon, i.e., <code>trange[end] = Inf</code> in case of an infinite horizon problem. The bound is computed via a SOS program of degree d solved with an appropriate method given by solver.</p><p>The bound can be tightened by populating trange or increasing <code>d</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FHoltorf/MarkovBounds.jl/blob/8420eb38a796e1e331aea0a29d46a99dc414e0f0/src/sos_programs_control.jl#L3-L16">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tutorials/optimal_control/">« Optimal Population Control of Noisy Lotka-Volterra System</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Tuesday 5 December 2023 15:09">Tuesday 5 December 2023</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
