<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Functionalities · MarkovBounds.jl</title><link rel="canonical" href="https://FHoltorf.github.io/MarkovBounds.jl/functionalities/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">MarkovBounds.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../background/">Background</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorials/birth_death_process/">Analysis of a Birth-Death Processes</a></li><li><a class="tocitem" href="../tutorials/jump_diffusion_process/">Analysis of Cox-Ingersoll-Ross Model Modified by Jumps</a></li><li><a class="tocitem" href="../tutorials/optimal_control/">Optimal Population Control of Noisy Lotka-Volterra System</a></li></ul></li><li class="is-active"><a class="tocitem" href>Functionalities</a><ul class="internal"><li><a class="tocitem" href="#Problem-Specification"><span>Problem Specification</span></a></li><li><a class="tocitem" href="#Bounds-on-Stationary-Moments-of-Markov-Processes"><span>Bounds on Stationary Moments of Markov Processes</span></a></li><li><a class="tocitem" href="#Bounds-on-Transient-Moments-of-Markov-Processes"><span>Bounds on Transient Moments of Markov Processes</span></a></li><li><a class="tocitem" href="#Bounds-on-Stochastic-Optimal-Control-Problems"><span>Bounds on Stochastic Optimal Control Problems</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Functionalities</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Functionalities</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/FHoltorf/MarkovBounds.jl/blob/master/docs/src/functionalities.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Functionalities-of-MarkovBounds.jl"><a class="docs-heading-anchor" href="#Functionalities-of-MarkovBounds.jl">Functionalities of MarkovBounds.jl</a><a id="Functionalities-of-MarkovBounds.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Functionalities-of-MarkovBounds.jl" title="Permalink"></a></h1><h2 id="Problem-Specification"><a class="docs-heading-anchor" href="#Problem-Specification">Problem Specification</a><a id="Problem-Specification-1"></a><a class="docs-heading-anchor-permalink" href="#Problem-Specification" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MarkovBounds.MarkovProcess" href="#MarkovBounds.MarkovProcess"><code>MarkovBounds.MarkovProcess</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">MarkovProcess</code></pre><p>An abstract type to define stochastic processes that are supported by MarkovBounds.jl. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FHoltorf/MarkovBounds.jl/blob/eb187982ea9f91b57e40a93aef527905e5102145/src/processes.jl#L5-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MarkovBounds.JumpProcess" href="#MarkovBounds.JumpProcess"><code>MarkovBounds.JumpProcess</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">JumpProcess(x, a, h, X = FullSpace();
            iv = PV{true}(&quot;t&quot;), controls = [], poly_vars = Dict())</code></pre><p>constructor returns <code>JumpProcess</code> object with fields</p><ul><li><code>x</code> - vector containing the system state. Can be specified both as PolyVar type object       from DynamicPolynomials.jl or Num type object generated by Catalyst.jl/ModelingToolkit.jl.        In the latter case, PolyVar variables with analogous names are generated automatically and       a dictionary is assembled that keeps track of this transformation.</li><li><code>a</code> - vector containing the rate coefficients for each independent jump in the system</li><li><code>h</code> - vector of vectors containing the jump functions </li><li><code>X</code> - basic semialgebraic set enclosing the state space of the process</li><li><code>iv</code> - independent variable of the process (usually time)</li><li><code>controls</code> - vector of control variables (empty if there are none)</li><li><code>poly_vars</code> - Dict mapping symbolic variables created by Catalyst.jl or ModelingToolkit.jl to generated PolyVar placeholders.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FHoltorf/MarkovBounds.jl/blob/eb187982ea9f91b57e40a93aef527905e5102145/src/processes.jl#L12-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MarkovBounds.ReactionProcess" href="#MarkovBounds.ReactionProcess"><code>MarkovBounds.ReactionProcess</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ReactionProcess(rn::ReactionSystem, params = Dict())</code></pre><p>constructor returns <code>ReactionProcess</code> object generated from Catalyst.jl <code>ReactionSystem</code> object with given parameters. The fields of ReactionProcess objects are</p><ul><li><code>ReactionSystem</code>- underlying ReactionSystem object as generated by Catalyst.jl</li><li><code>JumpProcess</code> - JumpProcess object describing a <code>JumpProcess</code> that is equivalent to the stochastic reaction network described by ReactionSystem</li><li><code>species_to_index</code> - Dictionary mapping chemical species to its internally used variable species<em>to</em>index</li><li><code>species_to_state</code> - Dictionary mapping species to equivalent state in the JumpProcess</li><li><code>state_to_species</code> - Dictionary mapping state in <code>JumpProcess</code> to species in reaction network</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FHoltorf/MarkovBounds.jl/blob/eb187982ea9f91b57e40a93aef527905e5102145/src/processes.jl#L47-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MarkovBounds.DiffusionProcess" href="#MarkovBounds.DiffusionProcess"><code>MarkovBounds.DiffusionProcess</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DiffusionProcess(x, f, σ, X = FullSpace();
                 iv = PV{true}(&quot;t&quot;), controls = [], poly_vars = Dict())</code></pre><p>constructor returns <code>DiffusionProcess</code> object with fields</p><ul><li><code>x</code> - vector containing the system state. Can be specified both as PolyVar type object       from DynamicPolynomials.jl or Num type object generated by Catalyst.jl/ModelingToolkit.jl.        In the latter case, PolyVar variables with analogous names are generated automatically and       a dictionary is assembled that keeps track of this transformation.</li><li><code>f</code> - vector of drift coefficients for each state</li><li><code>σ</code> - diffusion matrix of the process</li><li><code>X</code> - basic semialgebraic set enclosing the state space of the process</li><li><code>iv</code> - independent variable of the process (usually time)</li><li><code>controls</code> - vector of control variables (empty if there are none)</li><li><code>poly_vars</code> - Dict mapping symbolic variables created by Catalyst.jl or ModelingToolkit.jl to generated PolyVar placeholders.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FHoltorf/MarkovBounds.jl/blob/eb187982ea9f91b57e40a93aef527905e5102145/src/processes.jl#L79-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MarkovBounds.JumpDiffusionProcess" href="#MarkovBounds.JumpDiffusionProcess"><code>MarkovBounds.JumpDiffusionProcess</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">JumpDiffusionProcess(x, a, h, f, σ, X = FullSpace()
                     iv = PV{true}(&quot;t&quot;), controls = [], poly_vars = Dict())</code></pre><p>constructor returns <code>JumpDiffusionProcess</code> object with fields</p><ul><li><code>x</code> - vector containing the system state. Can be specified both as PolyVar type object       from DynamicPolynomials.jl or Num type object generated by Catalyst.jl/ModelingToolkit.jl.        In the latter case, PolyVar variables with analogous names are generated automatically and       a dictionary is assembled that keeps track of this transformation.</li><li><code>a</code> - vector containing the rate coefficients for each independent jump in the system</li><li><code>h</code> - vector of vectors containing the jump functions </li><li><code>f</code> - vector of drift coefficients for each state</li><li><code>σ</code> - diffusion matrix of the process</li><li><code>X</code> - basic semialgebraic set enclosing the state space of the process</li><li><code>iv</code> - independent variable of the process (usually time)</li><li><code>controls</code> - vector of control variables (empty if there are none)</li><li><code>poly_vars</code> - Dict mapping symbolic variables created by Catalyst.jl or ModelingToolkit.jl to generated PolyVar placeholders.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FHoltorf/MarkovBounds.jl/blob/eb187982ea9f91b57e40a93aef527905e5102145/src/processes.jl#L134-L151">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MarkovBounds.ControlProcess" href="#MarkovBounds.ControlProcess"><code>MarkovBounds.ControlProcess</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ControlProcess(MP::MarkovProcess, T::Real, U, obj, PCs = [], TCs = [], dis_fac = 0)</code></pre><p>constructor returns object of type <code>ControlProcess</code> with fields</p><ul><li><code>MP</code> - MarkovProcess to be controlled</li><li><code>T</code> - length of the time horizon (can be Inf)</li><li><code>U</code> - closed basic semialgebraic set describing admissible control actions</li><li><code>PathChanceConstraints</code> - Array of chance path constraints</li><li><code>TerminalChanceConstraints</code> - Array of terminal chance constraints</li><li><code>discount_factor</code> - discount factor for accumulating stage cost</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FHoltorf/MarkovBounds.jl/blob/eb187982ea9f91b57e40a93aef527905e5102145/src/processes.jl#L178-L188">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MarkovBounds.LagrangeMayer" href="#MarkovBounds.LagrangeMayer"><code>MarkovBounds.LagrangeMayer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LagrangeMayer</code></pre><p>a type used to specify an objective function consisting of a Lagrange and Mayer term, i.e., <span>$\mathbb{E}\left[ \int_{0}^T l(x(t), u(t)) \, dt + m(x(T))\right]$</span>. The Lagrange and Mayer term are specified in terms of polynomial functions <span>$l : X \times U \to \mathbb{R}$</span> and <span>$m : X \to \mathbb{R}$</span>, respectively.</p><p>Fields: </p><ul><li><code>l</code> - <code>AbstractPolynomialLike</code> determining the Lagrange term</li><li><code>m</code> - <code>AbstractPolynomialLike</code> determining the Mayer term</li></ul><p>If only a Lagrange or Mayer term is neede for specification of the objective function, one can make use of the functions <code>Lagrange(l::AbstractPolynomialLike)</code> and <code>Mayer(m::AbstractPolynomialLike)</code> for more convenient model specification.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FHoltorf/MarkovBounds.jl/blob/eb187982ea9f91b57e40a93aef527905e5102145/src/processes.jl#L229-L242">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MarkovBounds.TerminalSetProbability" href="#MarkovBounds.TerminalSetProbability"><code>MarkovBounds.TerminalSetProbability</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">TerminalSetProbability</code></pre><p>a type used to specify an objective function quantifiying the probability for a supported Markov process  to occupy a specified closed basic semialgebraic set at the end of the control horizon specified in a <code>ControlProcess</code> object. </p><p>Fields: </p><ul><li>X - basic semialgebraic set whose occupation probability is to be quantified at the end of the control horizon</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FHoltorf/MarkovBounds.jl/blob/eb187982ea9f91b57e40a93aef527905e5102145/src/processes.jl#L216-L224">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MarkovBounds.ExitProbability" href="#MarkovBounds.ExitProbability"><code>MarkovBounds.ExitProbability</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ExitProbability</code></pre><p>a type used to specify an objective function quantifiying the probability for a supported Markov process  to exit a specified closed basic semialgebraic set on the time horizon specified in a <code>ControlProcess</code> object. </p><p>Fields: </p><ul><li>X - basic semialgebraic set whose exit probability is to be quantified</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FHoltorf/MarkovBounds.jl/blob/eb187982ea9f91b57e40a93aef527905e5102145/src/processes.jl#L202-L210">source</a></section></article><h2 id="Bounds-on-Stationary-Moments-of-Markov-Processes"><a class="docs-heading-anchor" href="#Bounds-on-Stationary-Moments-of-Markov-Processes">Bounds on Stationary Moments of Markov Processes</a><a id="Bounds-on-Stationary-Moments-of-Markov-Processes-1"></a><a class="docs-heading-anchor-permalink" href="#Bounds-on-Stationary-Moments-of-Markov-Processes" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MarkovBounds.stationary_polynomial-Tuple{MarkovProcess, AbstractPolynomialLike, Int64, Any}" href="#MarkovBounds.stationary_polynomial-Tuple{MarkovProcess, AbstractPolynomialLike, Int64, Any}"><code>MarkovBounds.stationary_polynomial</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">stationary_polynomial(MP::MarkovProcess, v::APL, d::Int, solver)</code></pre><p>returns a <strong>lower</strong> bound on the expecation of a polynomial observables <span>$v(x)$</span> at steady state of the Markov process <code>MP</code>. The bound is computed based on an SOS program over a polynomial of degree at most <code>d</code>; the bounds can be tightened by increasing <code>d</code>. The program is solved with <code>solver</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FHoltorf/MarkovBounds.jl/blob/eb187982ea9f91b57e40a93aef527905e5102145/src/sos_programs_stationary.jl#L28-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MarkovBounds.stationary_mean-Tuple{MarkovProcess, AbstractPolynomialLike, Int64, Any}" href="#MarkovBounds.stationary_mean-Tuple{MarkovProcess, AbstractPolynomialLike, Int64, Any}"><code>MarkovBounds.stationary_mean</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">stationary_mean(MP::MarkovProcess, v::APL, d::Int, solver)</code></pre><p>returns <strong>lower</strong> and <strong>upper</strong> bound on the observable <span>$v(x)$</span> at steady state of the Markov process <code>MP</code>. Bounds are computed based on SOS programs over a polynomial of degree at most <code>d</code>; the bounds can be tightened by increasing <code>d</code>. The program is solved with <code>solver</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FHoltorf/MarkovBounds.jl/blob/eb187982ea9f91b57e40a93aef527905e5102145/src/sos_programs_stationary.jl#L44-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MarkovBounds.stationary_mean" href="#MarkovBounds.stationary_mean"><code>MarkovBounds.stationary_mean</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">stationary_mean(rn::ReactionSystem, S0::Dict, S, d::Int, solver,
		scales = Dict(s =&gt; 1 for s in species(rn));
		auto_scaling = false)</code></pre><p>returns <strong>lower</strong> and <strong>upper</strong> bound on the mean of species <code>S</code> of the reaction network <code>rn</code> with initial condition <code>S0</code> (for all species!). The bound is based on an SOS program of order <code>d</code> solved via <code>solver</code>; the bounds can be tightened by increasing <code>d</code>.</p><p>For numerical stability, it is recommended to provide scales of the expected magnitude of molecular counts for the different species at steady state. If the system is <strong>closed</strong> it is also possible to enable auto_scaling which will find the maximum molecular counts for each species under stoichiometry constraints (via LP).</p><p>If the initial condition of the reaction network under investigation is unknown or irrelevant, simply call</p><pre><code class="language-none">stationary_mean(rn::ReactionSystem, S, d::Int, solver,
		scales = Dict(s =&gt; 1 for s in species(rn))).</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FHoltorf/MarkovBounds.jl/blob/eb187982ea9f91b57e40a93aef527905e5102145/src/sos_programs_stationary.jl#L63-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MarkovBounds.stationary_variance-Tuple{MarkovProcess, AbstractPolynomialLike, Int64, Any}" href="#MarkovBounds.stationary_variance-Tuple{MarkovProcess, AbstractPolynomialLike, Int64, Any}"><code>MarkovBounds.stationary_variance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">stationary_variance(MP::MarkovProcess, v::APL, d::Int, solver)</code></pre><p>returns SOS program of degree <code>d</code> for computation of an <strong>upper</strong> bound on the variance of a polynomial observables <code>v</code> at steady state of the Markov process <code>MP</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FHoltorf/MarkovBounds.jl/blob/eb187982ea9f91b57e40a93aef527905e5102145/src/sos_programs_stationary.jl#L100-L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MarkovBounds.stationary_variance" href="#MarkovBounds.stationary_variance"><code>MarkovBounds.stationary_variance</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">stationary_variance(rn::ReactionSystem, S0, x, d::Int, solver,
		    scales = Dict(s =&gt; 1 for s in species(rn));
		    auto_scaling = false)</code></pre><p>returns <strong>upper</strong> bound on the variance of species <code>S</code> of the reaction network rn with initial condition <code>S0</code> (for all species!). The bound is based on an SOS program of degree <code>d</code> solved via <code>solver</code>; the bound can be tightened by increasing <code>d</code>.</p><p>For numerical stability, it is recommended to provide scales of the expected magnitude of molecular counts for the different species at steady state. If the system is <strong>closed</strong> it is also possible to enable <code>auto_scaling</code> which will find the maximum molecular counts for each species under stoichiometry constraints (via LP).</p><p>If the initial condition of the reaction network under investigation is unknown or irrelevant, simply call</p><pre><code class="language-none">stationary_variance(rn::ReactionSystem, S, d::Int, solver,
		    scales = Dict(s =&gt; 1 for s in species(rn)))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FHoltorf/MarkovBounds.jl/blob/eb187982ea9f91b57e40a93aef527905e5102145/src/sos_programs_stationary.jl#L132-L153">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MarkovBounds.stationary_covariance_ellipsoid-Tuple{MarkovProcess, Vector{var&quot;#s29&quot;} where var&quot;#s29&quot;&lt;:AbstractPolynomialLike, Int64, Any}" href="#MarkovBounds.stationary_covariance_ellipsoid-Tuple{MarkovProcess, Vector{var&quot;#s29&quot;} where var&quot;#s29&quot;&lt;:AbstractPolynomialLike, Int64, Any}"><code>MarkovBounds.stationary_covariance_ellipsoid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">stationary_covariance_ellipsoid(MP::MarkovProcess, v::Vector{&lt;:APL}, d::Int, solver)</code></pre><p>returns an <strong>upper</strong> on the volume of the covariance ellipsoid of a vector of polynomial observables <span>$v(x)$</span>, i.e., <span>$\text{det}(\mathbb{E} [v(x)v(x)^\top] - \mathbb{E}[v(x)] \mathbb{E}[v(x)]^\top)$</span>, at steady state of the Markov process <code>MP</code>. The bounds are computed via an SOS program of degree <code>d</code>, hence can be tightened by increasing <code>d</code>. This computation requires a <code>solver</code> that can handle exponential cone constraints.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FHoltorf/MarkovBounds.jl/blob/eb187982ea9f91b57e40a93aef527905e5102145/src/sos_programs_stationary.jl#L168-L177">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MarkovBounds.stationary_covariance_ellipsoid" href="#MarkovBounds.stationary_covariance_ellipsoid"><code>MarkovBounds.stationary_covariance_ellipsoid</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">stationary_covariance_ellipsoid(rn::ReactionSystem, S0::Dict, S::AbstractVector, d::Int, solver,
				scales = Dict(s =&gt; 1 for s in species(rn));
				auto_scaling = false)</code></pre><p>returns an <strong>upper</strong> on the volume of the covariance ellipsoid of any subset <code>S</code> of the chemical species in the reaction network <code>rn</code>, i.e., <span>$\text{det}(\mathbb{E}[SS^\top] - \mathbb{E}[S] \mathbb{E}[S]^\top)$</span>, at steady state of the associated jump process. The reaction network is assumed to have the deterministic initial state <code>S0</code> (all species must be included here!). The bounds are computed via an SOS program of degree <code>d</code>, hence can be tightened by increasing <code>d</code>. This computation requires a solver that can deal with exponential cone constraints.</p><p>For numerical stability, it is recommended to provide scales of the expected magnitude of molecular counts for the different species at steady state. If the system is <strong>closed</strong> it is also possible to enable auto_scaling which will find the maximum molecular counts for each species under stoichiometry constraints (via LP).</p><p>If the initial condition of the reaction network under investigation is unknown or irrelevant, simply call</p><pre><code class="language-none">stationary_covariance_ellipsoid(rn::ReactionSystem, S, d::Int, solver,
				scales = Dict(s =&gt; 1 for s in species(rn)))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FHoltorf/MarkovBounds.jl/blob/eb187982ea9f91b57e40a93aef527905e5102145/src/sos_programs_stationary.jl#L213-L237">source</a></section></article><h2 id="Bounds-on-Transient-Moments-of-Markov-Processes"><a class="docs-heading-anchor" href="#Bounds-on-Transient-Moments-of-Markov-Processes">Bounds on Transient Moments of Markov Processes</a><a id="Bounds-on-Transient-Moments-of-Markov-Processes-1"></a><a class="docs-heading-anchor-permalink" href="#Bounds-on-Transient-Moments-of-Markov-Processes" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MarkovBounds.transient_polynomial-Tuple{MarkovProcess, Dict, AbstractPolynomialLike, Int64, AbstractVector{var&quot;#s29&quot;} where var&quot;#s29&quot;&lt;:Real, Any}" href="#MarkovBounds.transient_polynomial-Tuple{MarkovProcess, Dict, AbstractPolynomialLike, Int64, AbstractVector{var&quot;#s29&quot;} where var&quot;#s29&quot;&lt;:Real, Any}"><code>MarkovBounds.transient_polynomial</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">transient_polynomial(MP::MarkovProcess, μ0::Dict, v::APL, d::Int, trange::AbstractVector{&lt;:Real}, solver)</code></pre><p>returns a <strong>lower</strong> bound on <span>$\mathbb{E}[v(x(T))]$</span> where <span>$v$</span> is a polynomial and <span>$x(T)$</span> the state of the Markov process <code>MP</code> at time <code>T = trange[end]</code>. <code>μ0</code> encodes the distribution of the initial state of the process in terms of its moments; specifically, it maps monomials to the respective moments of the initial distribution. <code>trange</code> is an <strong>ordered</strong> collection of time points used to discretize the time horizon <span>$[0,T]$</span>, i.e., <code>T = trange[end]</code>. Populating <code>trange</code> and increasing <code>d</code> improves the computed bound.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FHoltorf/MarkovBounds.jl/blob/eb187982ea9f91b57e40a93aef527905e5102145/src/sos_programs_transient.jl#L54-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MarkovBounds.transient_mean-Tuple{MarkovProcess, Dict, AbstractPolynomialLike, Int64, AbstractVector{var&quot;#s29&quot;} where var&quot;#s29&quot;&lt;:Real, Any}" href="#MarkovBounds.transient_mean-Tuple{MarkovProcess, Dict, AbstractPolynomialLike, Int64, AbstractVector{var&quot;#s29&quot;} where var&quot;#s29&quot;&lt;:Real, Any}"><code>MarkovBounds.transient_mean</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">transient_mean(MP::MarkovProcess, μ0::Dict, x::APL, d::Int, trange::AbstractVector{&lt;:Real}, solver)</code></pre><p>returns a <strong>lower</strong> and <strong>upper</strong> bound on <span>$\mathbb{E}[v(x(T))]$</span> where <span>$v$</span> is a polynomial and <span>$x(T)$</span> the state of the Markov process <code>MP</code> at time <code>T = trange[end]</code>. <code>μ0</code> encodes the distribution of the initial state of the process in terms of its moments; specifically, it maps monomials to the respective moments of the initial distribution. trange is an <strong>ordered</strong> collection of time points used to discretize the time horizon <span>$[0,T]$</span>, i.e., <code>T = trange[end]</code>. Populating <code>trange</code> and increasing <code>d</code> improves the computed bounds.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FHoltorf/MarkovBounds.jl/blob/eb187982ea9f91b57e40a93aef527905e5102145/src/sos_programs_transient.jl#L80-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MarkovBounds.transient_mean" href="#MarkovBounds.transient_mean"><code>MarkovBounds.transient_mean</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">transient_mean(rn::ReactionSystem, S0::Dict, S, d::Int, trange::AbstractVector{&lt;:Number}, solver,
		scales = Dict(s =&gt; 1 for s in species(rn));
		auto_scaling = false)</code></pre><p>returns a <strong>lower</strong> and <strong>upper</strong> bound on the mean of the molecular count of species <code>S</code> in reaction network <code>rn</code> at time <code>T = trange[end]</code>. <code>S0</code> refers to the <strong>deterministic</strong> initial state of the reaction system (including all species!). <code>trange</code> is an <strong>ordered</strong> collection of time points used to discretize the time horizon <span>$[0,T]$</span>, i.e., <code>T = trange[end]</code>. Populating trange and increasing <code>d</code> improves the computed bounds.</p><p>For numerical stability, it is recommended to provide scales of the expected magnitude of molecular counts for the different species at steady state. If the system is <strong>closed</strong> it is also possible to enable auto_scaling which will find the maximum molecular counts for each species under stoichiometry constraints (via LP).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FHoltorf/MarkovBounds.jl/blob/eb187982ea9f91b57e40a93aef527905e5102145/src/sos_programs_transient.jl#L107-L124">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MarkovBounds.transient_variance-Tuple{MarkovProcess, Dict, AbstractPolynomialLike, Int64, AbstractVector{var&quot;#s29&quot;} where var&quot;#s29&quot;&lt;:Real, Any}" href="#MarkovBounds.transient_variance-Tuple{MarkovProcess, Dict, AbstractPolynomialLike, Int64, AbstractVector{var&quot;#s29&quot;} where var&quot;#s29&quot;&lt;:Real, Any}"><code>MarkovBounds.transient_variance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">transient_variance(MP::MarkovProcess, μ0::Dict, v::APL, d::Int, trange::AbstractVector{&lt;:Real}, solver)</code></pre><p>returns an <strong>upper</strong> bound on <span>$\mathbb{E}[v(x(T))^2] - \mathbb{E}[v(x(T))]^2$</span> where <span>$v$</span> is a polynomial and <span>$x(T)$</span> the state of the Markov process <code>MP</code> at time <code>T = trange[end]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FHoltorf/MarkovBounds.jl/blob/eb187982ea9f91b57e40a93aef527905e5102145/src/sos_programs_transient.jl#L134-L139">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MarkovBounds.transient_variance" href="#MarkovBounds.transient_variance"><code>MarkovBounds.transient_variance</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">transient_variance(rn::ReactionSystem, S0::Dict, S, d::Int, trange::AbstractVector{&lt;:Real}, solver,
		    scales = Dict(s =&gt; 1 for s in species(rn));
			auto_scaling = false)</code></pre><p>returns an <strong>upper</strong> bound on the variance of species <code>S</code> in the reaction network <code>rn</code> at time <code>T = trange[end]</code>. <code>S0</code> refers to the <strong>deterministic</strong> initial state of the reaction system (including all species!). <code>trange</code> is an <strong>ordered</strong> collection of time points used to discretize the time horizon <span>$[0,T]$</span>, i.e., <code>T = trange[end]</code>. Populating <code>trange</code> and increasing <code>d</code> improves the computed bounds.</p><p>For numerical stability, it is recommended to provide scales of the expected magnitude of molecular counts for the different species at steady state. If the system is <strong>closed</strong> it is also possible to enable <code>auto_scaling</code> which will find the maximum molecular counts for each species under stoichiometry constraints (via LP).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FHoltorf/MarkovBounds.jl/blob/eb187982ea9f91b57e40a93aef527905e5102145/src/sos_programs_transient.jl#L182-L199">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MarkovBounds.transient_covariance_ellipsoid-Tuple{MarkovProcess, Dict, Vector{AbstractPolynomialLike}, Int64, AbstractVector{var&quot;#s29&quot;} where var&quot;#s29&quot;&lt;:Real, Any}" href="#MarkovBounds.transient_covariance_ellipsoid-Tuple{MarkovProcess, Dict, Vector{AbstractPolynomialLike}, Int64, AbstractVector{var&quot;#s29&quot;} where var&quot;#s29&quot;&lt;:Real, Any}"><code>MarkovBounds.transient_covariance_ellipsoid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">transient_covariance_ellipsoid(MP::MarkovProcess, μ0::Dict, v::Vector{APL}, d::Int, trange::AbstractVector{&lt;:Real}, solver)</code></pre><p>returns an <strong>upper</strong> bound on the volume of the covariance ellipsoid <span>$\text{det}(\mathbb{E}[v(x(T))v(x(T))^\top] - \mathbb{E}[v(x(T))] \mathbb{E}[v(x(T))]^\top)$</span>, where <span>$v$</span> is a polynomial and <span>$x(T)$</span> the state of the Markov process <code>MP</code> at time <code>T = trange[end]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FHoltorf/MarkovBounds.jl/blob/eb187982ea9f91b57e40a93aef527905e5102145/src/sos_programs_transient.jl#L208-L213">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MarkovBounds.transient_covariance_ellipsoid" href="#MarkovBounds.transient_covariance_ellipsoid"><code>MarkovBounds.transient_covariance_ellipsoid</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">transient_covariance_ellipsoid(rn::ReactionSystem, S0::Dict, S::AbstractVector, d::Int, trange::AbstractVector{&lt;:Real}, solver,
						scales = Dict(s =&gt; 1 for s in species(rn));
						auto_scaling = false)</code></pre><p>returns an <strong>upper</strong> bound on the volume of the covariance ellipsoid associated with any collection of chemical species in the reaction network <code>rn</code> at time <code>T = trange[end]</code>. S0 refers to the <strong>deterministic</strong> initial state of the reaction system (including all species!). <code>trange</code> is an <strong>ordered</strong> collection of time points used to discretize the time horizon <span>$[0,T]$</span>, i.e., <code>T = trange[end]</code>. Populating <code>trange</code> and increasing <code>d</code> improves the computed bounds.</p><p>For numerical stability, it is recommended to provide scales of the expected magnitude of molecular counts for the different species at steady state. If the system is <strong>closed</strong> it is also possible to enable auto_scaling which will find the maximum molecular counts for each species under stoichiometry constraints (via LP).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FHoltorf/MarkovBounds.jl/blob/eb187982ea9f91b57e40a93aef527905e5102145/src/sos_programs_transient.jl#L264-L281">source</a></section></article><h2 id="Bounds-on-Stochastic-Optimal-Control-Problems"><a class="docs-heading-anchor" href="#Bounds-on-Stochastic-Optimal-Control-Problems">Bounds on Stochastic Optimal Control Problems</a><a id="Bounds-on-Stochastic-Optimal-Control-Problems-1"></a><a class="docs-heading-anchor-permalink" href="#Bounds-on-Stochastic-Optimal-Control-Problems" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MarkovBounds.optimal_control-Tuple{ControlProcess, Dict, Int64, AbstractVector{var&quot;#s29&quot;} where var&quot;#s29&quot;&lt;:Real, Any}" href="#MarkovBounds.optimal_control-Tuple{ControlProcess, Dict, Int64, AbstractVector{var&quot;#s29&quot;} where var&quot;#s29&quot;&lt;:Real, Any}"><code>MarkovBounds.optimal_control</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">optimal_control(CP::ControlProcess, μ0::Dict, d::Int, trange::AbstractVector{&lt;:Real}, solver)</code></pre><p>returns a <strong>lower</strong> bound on the objective value of the (stochastic) optimal control problem specified by CP. <code>μ0</code> encodes information about the distribution of the initial state of the process; specifically, <code>μ0</code> maps a given monomial to the corresponding moment of the initial distribution. trange refers to an <em>ordered</em> set of time points discretizing the control horizon. trange[end] should coincide with the end of the control horizon, i.e., <code>trange[end] = Inf</code> in case of an infinite horizon problem. The bound is computed via a SOS program of degree d solved with an appropriate method given by solver.</p><p>The bound can be tightened by populating trange or increasing <code>d</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FHoltorf/MarkovBounds.jl/blob/eb187982ea9f91b57e40a93aef527905e5102145/src/sos_programs_control.jl#L3-L16">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tutorials/optimal_control/">« Optimal Population Control of Noisy Lotka-Volterra System</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 15 November 2021 01:19">Monday 15 November 2021</span>. Using Julia version 1.6.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
