var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = MarkovBoundsSOS","category":"page"},{"location":"#MarkovBoundsSOS-Documentation","page":"Home","title":"MarkovBoundsSOS Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for MarkovBoundsSOS.","category":"page"},{"location":"#Bounds-on-Stationary-Moments-of-Markov-Processes","page":"Home","title":"Bounds on Stationary Moments of Markov Processes","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"stationary_polynomial(MP::MarkovProcess, v::APL, d::Int, solver)\nstationary_mean(MP::MarkovProcess, v::APL, d::Int, solver)\nstationary_mean(rn::ReactionSystem, S0::Dict, S, d::Int, solver,\n                scales = Dict(s => 1 for s in speceies(rn));\n                auto_scaling = false)\nstationary_variance(MP::MarkovProcess, v::APL, d::Int, solver)\nstationary_variance(rn::ReactionSystem, S0, x, d::Int, solver,\n                    scales = Dict(s => 1 for s in speceies(rn));\n                    auto_scaling = false)\nstationary_covariance_ellipsoid(MP::MarkovProcess, v::Vector{<:APL}, d::Int, solver)\nstationary_covariance_ellipsoid(rn::ReactionSystem, S0::Dict, S::AbstractVector, d::Int, solver,\n                                scales = Dict(s => 1 for s in speceies(rn));\n                                auto_scaling = false)","category":"page"},{"location":"#MarkovBoundsSOS.stationary_polynomial-Tuple{MarkovProcess, AbstractPolynomialLike, Int64, Any}","page":"Home","title":"MarkovBoundsSOS.stationary_polynomial","text":"stationary_polynomial(MP::MarkovProcess, v::APL, d::Int, solver)\n\nreturns a lower bound on the expecation of a polynomial observables v(x) at steady state of the Markov process MP. The bound is computed based on an SOS program over a polynomial of degree at most d; the bounds can be tightened by increasing d. The program is solved with solver.\n\n\n\n\n\n","category":"method"},{"location":"#MarkovBoundsSOS.stationary_mean-Tuple{MarkovProcess, AbstractPolynomialLike, Int64, Any}","page":"Home","title":"MarkovBoundsSOS.stationary_mean","text":"stationary_mean(MP::MarkovProcess, v::APL, d::Int, solver)\n\nreturns lower and upper bound on the observable v(x) at steady state of the Markov process MP. Bounds are computed based on SOS programs over a polynomial of degree at most d; the bounds can be tightened by increasing d. The program is solved with solver.\n\n\n\n\n\n","category":"method"},{"location":"#MarkovBoundsSOS.stationary_variance-Tuple{MarkovProcess, AbstractPolynomialLike, Int64, Any}","page":"Home","title":"MarkovBoundsSOS.stationary_variance","text":"stationary_variance(MP::MarkovProcess, v::APL, d::Int, solver)\n\nreturns SOS program of degree d for computation of an upper bound on the variance of a polynomial observables v at steady state of the Markov process MP.\n\n\n\n\n\n","category":"method"},{"location":"#MarkovBoundsSOS.stationary_variance","page":"Home","title":"MarkovBoundsSOS.stationary_variance","text":"stationary_variance(rn::ReactionSystem, S0, x, d::Int, solver,\n\t\t    scales = Dict(s => 1 for s in species(rn));\n\t\t    auto_scaling = false)\n\nreturns upper bound on the variance of species S of the reaction network rn with initial condition S0 (for all species!). The bound is based on an SOS program of degree d solved via solver; the bound can be tightened by increasing d.\n\nFor numerical stability, it is recommended to provide scales of the expected magnitude of molecular counts for the different species at steady state. If the system is closed it is also possible to enable auto_scaling which will find the maximum molecular counts for each species under stoichiometry constraints (via LP).\n\nIf the initial condition of the reaction network under investigation is unknown or irrelevant, simply call\n\nstationary_variance(rn::ReactionSystem, S, d::Int, solver,\n\t\t    scales = Dict(s => 1 for s in species(rn)))\n\n\n\n\n\n","category":"function"},{"location":"#MarkovBoundsSOS.stationary_covariance_ellipsoid","page":"Home","title":"MarkovBoundsSOS.stationary_covariance_ellipsoid","text":"stationary_covariance_ellipsoid(rn::ReactionSystem, S0::Dict, S::AbstractVector, d::Int, solver,\n\t\t\t\tscales = Dict(s => 1 for s in species(rn));\n\t\t\t\tauto_scaling = false)\n\nreturns an upper on the volume of the covariance ellipsoid of any subset S of the chemical species in the reaction network rn, i.e., det(𝔼(SSᵀ)), at steady state of the associated jump process. The reaction network is assumed to have the deterministic initial state S0 (all species must be included here!). The bounds are computed via an SOS program of degree d, hence can be tightened by increasing d. This computation requires a solver that can deal with exponential cone constraints.\n\nFor numerical stability, it is recommended to provide scales of the expected magnitude of molecular counts for the different species at steady state. If the system is closed it is also possible to enable auto_scaling which will find the maximum molecular counts for each species under stoichiometry constraints (via LP).\n\nIf the initial condition of the reaction network under investigation is unknown or irrelevant, simply call\n\nstationary_covariance_ellipsoid(rn::ReactionSystem, S, d::Int, solver,\n\t\t\t\tscales = Dict(s => 1 for s in species(rn)))\n\n\n\n\n\n","category":"function"},{"location":"#Bounds-on-Transient-Moments-of-Markov-Processes","page":"Home","title":"Bounds on Transient Moments of Markov Processes","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"transient_polynomial(MP::MarkovProcess, μ0::Dict, v::APL, d::Int, trange::AbstractVector{<:Real}, solver)\ntransient_mean(MP::MarkovProcess, μ0::Dict, x::APL, d::Int, trange::AbstractVector{<:Real}, solver)\ntransient_mean(rn::ReactionSystem, S0::Dict, S, d::Int, trange::AbstractVector{<:Number}, solver,\n            scales = Dict(s => 1 for s in speceies(rn));\n            auto_scaling = false)\ntransient_variance(MP::MarkovProcess, μ0::Dict, v::APL, d::Int, trange::AbstractVector{<:Real}, solver)\ntransient_variance(rn::ReactionSystem, S0::Dict, S, d::Int, trange::AbstractVector{<:Real}, solver,\n            scales = Dict(s => 1 for s in speceies(rn));\n            auto_scaling = false)\ntransient_covariance_ellipsoid(MP::MarkovProcess, μ0::Dict, v::Vector{APL}, d::Int, trange::AbstractVector{<:Real}, solver)\ntransient_covariance_ellipsoid(rn::ReactionSystem, S0::Dict, S::AbstractVector, d::Int, trange::AbstractVector{<:Real}, solver,\n            scales = Dict(s => 1 for s in speceies(rn));\n            auto_scaling = false)","category":"page"},{"location":"#MarkovBoundsSOS.transient_polynomial-Tuple{MarkovProcess, Dict, AbstractPolynomialLike, Int64, AbstractVector{var\"#s25\"} where var\"#s25\"<:Real, Any}","page":"Home","title":"MarkovBoundsSOS.transient_polynomial","text":"transient_polynomial(MP::MarkovProcess, μ0::Dict, v::APL, d::Int, trange::AbstractVector{<:Real}, solver)\n\nreturns a lower bound on 𝔼[v(x(T))] where v is a polynomial and x(T) the state of the Markov process MP at time T. μ0 encodes the distribution of the initial state of the process in terms of its moments; specifically, it maps monomials to the respective moments of the initial distribution. trange is an ordered collection of time points used to discretize the time horizon [0,T], i.e., trange[end] = T. Populating trange and increasing d improves the computed bound.\n\n\n\n\n\n","category":"method"},{"location":"#MarkovBoundsSOS.transient_mean-Tuple{MarkovProcess, Dict, AbstractPolynomialLike, Int64, AbstractVector{var\"#s25\"} where var\"#s25\"<:Real, Any}","page":"Home","title":"MarkovBoundsSOS.transient_mean","text":"transient_mean(MP::MarkovProcess, μ0::Dict, x::APL, d::Int, trange::AbstractVector{<:Real}, solver)\n\nreturns a lower and upper bound on 𝔼[v(x(T))] where v is a polynomial and x(T) the state of the Markov process MP at time T. μ0 encodes the distribution of the initial state of the process in terms of its moments; specifically, it maps monomials to the respective moments of the initial distribution. trange is an ordered collection of time points used to discretize the time horizon [0,T], i.e., trange[end] = T. Populating trange and increasing d improves the computed bounds.\n\n\n\n\n\n","category":"method"},{"location":"#MarkovBoundsSOS.transient_mean","page":"Home","title":"MarkovBoundsSOS.transient_mean","text":"transient_mean(rn::ReactionSystem, S0::Dict, S, d::Int, trange::AbstractVector{<:Number}, solver,\n\t\tscales = Dict(s => 1 for s in species(rn));\n\t\tauto_scaling = false)\n\nreturns a lower and upper bound on the mean of the molecular count of species S in reaction network rn at time T. S0 refers to the deterministic initial state of the reaction system (including all species!). trange is an ordered collection of time points used to discretize the time horizon [0,T], i.e., trange[end] = T. Populating trange and increasing d improves the computed bounds.\n\nFor numerical stability, it is recommended to provide scales of the expected magnitude of molecular counts for the different species at steady state. If the system is closed it is also possible to enable auto_scaling which will find the maximum molecular counts for each species under stoichiometry constraints (via LP).\n\n\n\n\n\n","category":"function"},{"location":"#MarkovBoundsSOS.transient_variance-Tuple{MarkovProcess, Dict, AbstractPolynomialLike, Int64, AbstractVector{var\"#s25\"} where var\"#s25\"<:Real, Any}","page":"Home","title":"MarkovBoundsSOS.transient_variance","text":"transient_variance(MP::MarkovProcess, μ0::Dict, v::APL, d::Int, trange::AbstractVector{<:Real}, solver)\n\nreturns an upper bound on 𝔼[v(x(T))²] - 𝔼[v(x(T))]² where v is a polynomial and x(T) the state of the Markov process MP at time T.\n\n\n\n\n\n","category":"method"},{"location":"#MarkovBoundsSOS.transient_variance","page":"Home","title":"MarkovBoundsSOS.transient_variance","text":"transient_variance(rn::ReactionSystem, S0::Dict, S, d::Int, trange::AbstractVector{<:Real}, solver,\n\t\t    scales = Dict(s => 1 for s in species(rn));\n\t\t\tauto_scaling = false)\n\nreturns an upper bound on the variance of species S in the reaction network rn at time T. S0 refers to the deterministic initial state of the reaction system (including all species!). trange is an ordered collection of time points used to discretize the time horizon [0,T], i.e., trange[end] = T. Populating trange and increasing d improves the computed bounds.\n\nFor numerical stability, it is recommended to provide scales of the expected magnitude of molecular counts for the different species at steady state. If the system is closed it is also possible to enable auto_scaling which will find the maximum molecular counts for each species under stoichiometry constraints (via LP).\n\n\n\n\n\n","category":"function"},{"location":"#MarkovBoundsSOS.transient_covariance_ellipsoid-Tuple{MarkovProcess, Dict, Vector{AbstractPolynomialLike}, Int64, AbstractVector{var\"#s25\"} where var\"#s25\"<:Real, Any}","page":"Home","title":"MarkovBoundsSOS.transient_covariance_ellipsoid","text":"transient_covariance_ellipsoid(MP::MarkovProcess, μ0::Dict, v::Vector{APL}, d::Int, trange::AbstractVector{<:Real}, solver)\n\nreturns an upper bound on the volume of the covariance ellipsoid det(𝔼(v(x(T))v(x(T))ᵀ)), where v is a polynomial and x(T) the state of the Markov process MP at time T.\n\n\n\n\n\n","category":"method"},{"location":"#MarkovBoundsSOS.transient_covariance_ellipsoid","page":"Home","title":"MarkovBoundsSOS.transient_covariance_ellipsoid","text":"transient_covariance_ellipsoid(rn::ReactionSystem, S0::Dict, S::AbstractVector, d::Int, trange::AbstractVector{<:Real}, solver,\n\t\t\t\t\t\tscales = Dict(s => 1 for s in species(rn));\n\t\t\t\t\t\tauto_scaling = false)\n\nreturns an upper bound on the volume of the covariance ellipsoid associated with any collection of chemical species in the reaction network rn at time T. S0 refers to the deterministic initial state of the reaction system (including all species!). trange is an ordered collection of time points used to discretize the time horizon [0,T], i.e., trange[end] = T. Populating trange and increasing d improves the computed bounds.\n\nFor numerical stability, it is recommended to provide scales of the expected magnitude of molecular counts for the different species at steady state. If the system is closed it is also possible to enable auto_scaling which will find the maximum molecular counts for each species under stoichiometry constraints (via LP).\n\n\n\n\n\n","category":"function"},{"location":"#Bounds-on-Stochastic-Optimal-Control-Problems","page":"Home","title":"Bounds on Stochastic Optimal Control Problems","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"optimal_control(CP::ControlProcess, μ0::Dict, d::Int, trange::AbstractVector{<:Real}, solver)","category":"page"},{"location":"#MarkovBoundsSOS.optimal_control-Tuple{ControlProcess, Dict, Int64, AbstractVector{var\"#s25\"} where var\"#s25\"<:Real, Any}","page":"Home","title":"MarkovBoundsSOS.optimal_control","text":"optimal_control(CP::ControlProcess, μ0::Dict, d::Int, trange::AbstractVector{<:Real}, solver)\n\nreturns a lower bound on the objective value of the (stochastic) optimal control problem specified by CP. μ0 encodes information about the distribution of the initial state of the process; specifically, μ0 maps a given monomial to the corresponding moment of the initial distribution. trange refers to an ordered set of time points discretizing the control horizon. trange[end] should coincide with the end of the control horizon, i.e., trange[end] = Inf in case of an infinite horizon problem. The bound is computed via a SOS program of degree d solved with an appropriate method given by solver.\n\nThe bound can be tightened by populating trange or increasing d.\n\n\n\n\n\n","category":"method"}]
}
