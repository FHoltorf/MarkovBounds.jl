<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Analysis of a Birth-Death Processes ¬∑ MarkovBounds.jl</title><link rel="canonical" href="https://FHoltorf.github.io/MarkovBounds.jl/tutorials/birth_death_process/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">MarkovBounds.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../background/">Background</a></li><li><span class="tocitem">Tutorials</span><ul><li class="is-active"><a class="tocitem" href>Analysis of a Birth-Death Processes</a></li><li><a class="tocitem" href="../jump_diffusion_process/">Analysis of Cox-Ingersoll-Ross Model Modified by Jumps</a></li><li><a class="tocitem" href="../optimal_control/">Optimal Population Control of Noisy Lotka-Volterra System</a></li></ul></li><li><a class="tocitem" href="../../functionalities/">Functionalities</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Analysis of a Birth-Death Processes</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Analysis of a Birth-Death Processes</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/FHoltorf/MarkovBounds.jl/blob/master/docs/src/tutorials/birth_death_process.md#" title="Edit on GitHub"><span class="docs-icon fab">ÔÇõ</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Analysis-of-a-Birth-Death-Processes"><a class="docs-heading-anchor" href="#Analysis-of-a-Birth-Death-Processes">Analysis of a Birth-Death Processes</a><a id="Analysis-of-a-Birth-Death-Processes-1"></a><a class="docs-heading-anchor-permalink" href="#Analysis-of-a-Birth-Death-Processes" title="Permalink"></a></h1><p>In this example we wish to study the statistics of the simple nonlinear birth-death process</p><pre><code class="language-none">‚àÖ ‚Üí A
2A ‚Üí A</code></pre><p>following mass-action kinetics. To define the underlying jump process it is convenient to utilize Catalyst.jl&#39;s functionality and simply define a reaction network with the above reactions.</p><pre><code class="language-julia">birth_death = @reaction_network begin
    1.0, ‚àÖ --&gt; A
    0.01, 2A --&gt; A
end</code></pre><p>We will need to make reference to the species A in the network at several occasions. We therefore extract the symbolic variable using Catalyst.jl&#39;s species function.</p><pre><code class="language-julia">A = species(birth_death)[1]</code></pre><p>Throughout, we will further assume that the initial state of the process is known with deterministic certainty. The initial condition is supplied in form of a dictionary mapping the symbolic variable of all species in the process to their initial value. In this case, we assume that the initial count of species A is 2.</p><pre><code class="language-julia">A0 = Dict(A =&gt; 2.0)</code></pre><p>On a technical note, it shall also be emphasized that in biochemical applications it is very important to provide scales for the molecular counts of the different species in the system. Otherwise numerical instabilities will likely cause inaccurate solutions. The scales are provided in the same format as the initial conditions. The scales need not be accurate and can be obtained in many sensible ways, for example by looking at a single trajectory of the network or even at the deterministic rate-law model. For closed systems, MarkovBoundsSOS allows to compute scales based on the stoichiometry in the system.</p><pre><code class="language-julia">A_scale = Dict(A =&gt; 10.0)</code></pre><p>With these pieces of input data, we can start analyzing the statistics of the stochastic reaction network/jump process.</p><p>For example, we can find upper and lower bounds on the mean count of species A with respect to the stationary distribution of the process. This can be done by calling the function <code>stationary_mean</code> specifying the reaction network, the species of which bounds are sought, an order for the relaxation used for computing the bounds, an appropriate solver and (if desired) scales for the different species as inputs. In our case the reaction network is the birth-death network defined above and we care species A. The order of the relaxation used is left to the user to decide on a trade-off between computational cost and bound quality; the larger the order is chosen, the better the bounds become (in absence of numerical issues). It is generally advisable to start with low orders (2-6) and only go beyond these values if necessary as numerical instabilities become more pronounced issues at high orders. While any SDP solver supported by JuMP (https://jump.dev/JuMP.jl/stable/installation/#Supported-solvers) can be used, we recommend with sticking with the interior-point based solvers such as Mosek, SeDuMi, SDPA, or SDPT3. With all these pieces in place, the bounds can be computed by a simple function call:</p><pre><code class="language-julia">mean_bounds = []
orders = [2, 4, 6, 8]
for relaxation_order in orders
    b = stationary_mean(birth_death, A, relaxation_order, Mosek.Optimizer, A_scale)
    push!(mean_bounds, b)
end</code></pre><p><img src="../images/birth_death_stat_means.svg" alt/></p><p>Similarly, we can compute an upper bound on the variance of the stationary distribution of the process.</p><pre><code class="language-julia">var_ub = []
orders = [2, 4, 6, 8]
for order in orders
    b = stationary_variance(birth_death, A, order, Mosek.Optimizer, A_scale)
    push!(var_ub, b)
end</code></pre><p><img src="../images/birth_death_stat_vars_ub.svg" alt/></p><p>While a lower bound of the variance can not be computed directly, we can use the fact that we can compute bounds on the expecation of any polynomial of the system state with respect to the stationary distribution. Accordingly, we can simply compute a lower bound on ùîº[A¬≤] and combine this with the previously computed upper bound on ùîº[A] to find a valid lower bound on the variance Var[A] = ùîº[A¬≤] - ùîº[A]¬≤. To that end, we first transform the reaction network into a ReactionProcess using the function <code>reaction_process_setup</code>. This <code>ReactionProcess</code> features a jump process that is equivalent to the reaction network, however, accounts for potential reaction invariants and applies scales to the state. Moreover, the <code>ReactionProcess</code> provides a map between the molecular species of the network on the states of the jump process for easy interpretation of the results.</p><pre><code class="language-julia">RP, x0 = reaction_process_setup(birth_death, A0, scales = A_scale)</code></pre><p>Now we can compute a lower bound on Var(A)</p><pre><code class="language-julia">var_lb = []
for order in orders
    b = stationary_polynomial(RP.JumpProcess, RP.species_to_state[A]^2, order, Mosek.Optimizer)
    push!(var_lb, b)
end</code></pre><p><img src="../images/birth_death_stat_vars_lb.svg" alt/></p><p>Everything presented above generalizes to the problem of bounding the expectation of moments and related statistics along at any finite time. For example, we can find lower and upper bounds on the mean molecular count of species A after 10 seconds:</p><pre><code class="language-none">`transient_mean(birth_death, A0, A, 4, [10.0], Mosek.Optimizer, A_scale)`</code></pre><p>These transient bounds can not only be improved by increasing the order of the relaxation but also by refining discretization of the temporal domain. This discretization is specified by providing an ordered list of time points in place of simply the time at which the bounds are to be evaluated. The last time point in this list refers to the time at which the bounds are evaluated.</p><p>This way, we can for example evaluate bounds on the trajectories of the mean and the variance of the molecular count of species A by computing bounds at different time points:</p><pre><code class="language-julia">var_ub = []
mean_bounds = []
nT = 10 # number of intervals used to discretize the time domain
Ts = [0.1, 0.5, 1.0, 1.5, 2.0, 5.0, 10.0, 15.0, 20.0, 30.0, 40.0, 50.0]
for T in Ts
    trange = range(0, T, length=nT+1)
    b = transient_mean(birth_death, A0, A, 4, trange, Mosek.Optimizer, A_scale)
    push!(mean_bounds, b)
    b = transient_variance(birth_death, A0, A, 4, trange, Mosek.Optimizer, A_scale)
    push!(var_ub, b)
end</code></pre><p>This way, we generate the following bounds on the moment trajectories of the process. </p><p><img src="../images/birth_death_transient.svg" alt/></p><p>For more detailes on the code used in this example, please review <a href="https://github.com/FHoltorf/MarkovBounds.jl/blob/master/tutorials/birth_death_process.ipynb">this jupyter notebook</a>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../background/">¬´ Background</a><a class="docs-footer-nextpage" href="../jump_diffusion_process/">Analysis of Cox-Ingersoll-Ross Model Modified by Jumps ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 22 June 2022 03:58">Wednesday 22 June 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
