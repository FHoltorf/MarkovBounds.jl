<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · MarkovBounds.jl</title><link rel="canonical" href="https://FHoltorf.github.io/MarkovBounds.jl/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">MarkovBounds.jl</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Bounds-on-Stationary-Moments-of-Markov-Processes"><span>Bounds on Stationary Moments of Markov Processes</span></a></li><li class="toplevel"><a class="tocitem" href="#Bounds-on-Transient-Moments-of-Markov-Processes"><span>Bounds on Transient Moments of Markov Processes</span></a></li><li class="toplevel"><a class="tocitem" href="#Bounds-on-Stochastic-Optimal-Control-Problems"><span>Bounds on Stochastic Optimal Control Problems</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/FHoltorf/MarkovBounds.jl/blob/master/docs/src/index.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="MarkovBounds.jl-Documentation"><a class="docs-heading-anchor" href="#MarkovBounds.jl-Documentation">MarkovBounds.jl Documentation</a><a id="MarkovBounds.jl-Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#MarkovBounds.jl-Documentation" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/FHoltorf/MarkovBounds.jl">MarkovBounds</a>.</p><h1 id="Bounds-on-Stationary-Moments-of-Markov-Processes"><a class="docs-heading-anchor" href="#Bounds-on-Stationary-Moments-of-Markov-Processes">Bounds on Stationary Moments of Markov Processes</a><a id="Bounds-on-Stationary-Moments-of-Markov-Processes-1"></a><a class="docs-heading-anchor-permalink" href="#Bounds-on-Stationary-Moments-of-Markov-Processes" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="MarkovBounds.stationary_polynomial-Tuple{MarkovProcess, AbstractPolynomialLike, Int64, Any}" href="#MarkovBounds.stationary_polynomial-Tuple{MarkovProcess, AbstractPolynomialLike, Int64, Any}"><code>MarkovBounds.stationary_polynomial</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">stationary_polynomial(MP::MarkovProcess, v::APL, d::Int, solver)</code></pre><p>returns a <em>lower</em> bound on the expecation of a polynomial observables v(x) at steady state of the Markov process MP. The bound is computed based on an SOS program over a polynomial of degree at most d; the bounds can be tightened by increasing d. The program is solved with solver.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FHoltorf/MarkovBounds.jl/blob/9e60607c4615fcbbfd338fbe7b6cbc3ba4459b73/src/sos_programs_stationary.jl#L28-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MarkovBounds.stationary_mean-Tuple{MarkovProcess, AbstractPolynomialLike, Int64, Any}" href="#MarkovBounds.stationary_mean-Tuple{MarkovProcess, AbstractPolynomialLike, Int64, Any}"><code>MarkovBounds.stationary_mean</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">stationary_mean(MP::MarkovProcess, v::APL, d::Int, solver)</code></pre><p>returns <em>lower</em> and <em>upper</em> bound on the observable v(x) at steady state of the Markov process MP. Bounds are computed based on SOS programs over a polynomial of degree at most d; the bounds can be tightened by increasing d. The program is solved with solver.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FHoltorf/MarkovBounds.jl/blob/9e60607c4615fcbbfd338fbe7b6cbc3ba4459b73/src/sos_programs_stationary.jl#L44-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MarkovBounds.stationary_mean" href="#MarkovBounds.stationary_mean"><code>MarkovBounds.stationary_mean</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">stationary_mean(rn::ReactionSystem, S0::Dict, S, d::Int, solver,
		scales = Dict(s =&gt; 1 for s in species(rn));
		auto_scaling = false)</code></pre><p>returns <em>lower</em> and <em>upper</em> bound on the mean of species S of the reaction network rn with initial condition S0 (for all species!). The bound is based on an SOS program of order d solved via solver; the bounds can be tightened by increasing d.</p><p>For numerical stability, it is recommended to provide scales of the expected magnitude of molecular counts for the different species at steady state. If the system is <em>closed</em> it is also possible to enable auto_scaling which will find the maximum molecular counts for each species under stoichiometry constraints (via LP).</p><p>If the initial condition of the reaction network under investigation is unknown or irrelevant, simply call</p><pre><code class="language-none">stationary_mean(rn::ReactionSystem, S, d::Int, solver,
		scales = Dict(s =&gt; 1 for s in species(rn))).</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FHoltorf/MarkovBounds.jl/blob/9e60607c4615fcbbfd338fbe7b6cbc3ba4459b73/src/sos_programs_stationary.jl#L62-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MarkovBounds.stationary_variance-Tuple{MarkovProcess, AbstractPolynomialLike, Int64, Any}" href="#MarkovBounds.stationary_variance-Tuple{MarkovProcess, AbstractPolynomialLike, Int64, Any}"><code>MarkovBounds.stationary_variance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">stationary_variance(MP::MarkovProcess, v::APL, d::Int, solver)</code></pre><p>returns SOS program of degree d for computation of an <em>upper</em> bound on the variance of a polynomial observables v at steady state of the Markov process MP.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FHoltorf/MarkovBounds.jl/blob/9e60607c4615fcbbfd338fbe7b6cbc3ba4459b73/src/sos_programs_stationary.jl#L99-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MarkovBounds.stationary_variance" href="#MarkovBounds.stationary_variance"><code>MarkovBounds.stationary_variance</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">stationary_variance(rn::ReactionSystem, S0, x, d::Int, solver,
		    scales = Dict(s =&gt; 1 for s in species(rn));
		    auto_scaling = false)</code></pre><p>returns <em>upper</em> bound on the variance of species S of the reaction network rn with initial condition S0 (for all species!). The bound is based on an SOS program of degree d solved via solver; the bound can be tightened by increasing d.</p><p>For numerical stability, it is recommended to provide scales of the expected magnitude of molecular counts for the different species at steady state. If the system is <em>closed</em> it is also possible to enable auto_scaling which will find the maximum molecular counts for each species under stoichiometry constraints (via LP).</p><p>If the initial condition of the reaction network under investigation is unknown or irrelevant, simply call</p><pre><code class="language-none">stationary_variance(rn::ReactionSystem, S, d::Int, solver,
		    scales = Dict(s =&gt; 1 for s in species(rn)))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FHoltorf/MarkovBounds.jl/blob/9e60607c4615fcbbfd338fbe7b6cbc3ba4459b73/src/sos_programs_stationary.jl#L131-L152">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MarkovBounds.stationary_covariance_ellipsoid-Tuple{MarkovProcess, Vector{var&quot;#s25&quot;} where var&quot;#s25&quot;&lt;:AbstractPolynomialLike, Int64, Any}" href="#MarkovBounds.stationary_covariance_ellipsoid-Tuple{MarkovProcess, Vector{var&quot;#s25&quot;} where var&quot;#s25&quot;&lt;:AbstractPolynomialLike, Int64, Any}"><code>MarkovBounds.stationary_covariance_ellipsoid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">stationary_covariance_ellipsoid(MP::MarkovProcess, v::Vector{&lt;:APL}, d::Int, solver)</code></pre><p>returns an <em>upper</em> on the volume of the covariance ellipsoid of a vector of polynomial observables v(x), i.e., det(𝔼(v(x)v(x)ᵀ)), at steady state of the Markov process MP. The bounds are computed via an SOS program of degree d, hence can be tightened by increasing d. This computation requires a solver that can deal with exponential cone constraints.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FHoltorf/MarkovBounds.jl/blob/9e60607c4615fcbbfd338fbe7b6cbc3ba4459b73/src/sos_programs_stationary.jl#L167-L176">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MarkovBounds.stationary_covariance_ellipsoid" href="#MarkovBounds.stationary_covariance_ellipsoid"><code>MarkovBounds.stationary_covariance_ellipsoid</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">stationary_covariance_ellipsoid(rn::ReactionSystem, S0::Dict, S::AbstractVector, d::Int, solver,
				scales = Dict(s =&gt; 1 for s in species(rn));
				auto_scaling = false)</code></pre><p>returns an <em>upper</em> on the volume of the covariance ellipsoid of any subset S of the chemical species in the reaction network rn, i.e., det(𝔼(SSᵀ)), at steady state of the associated jump process. The reaction network is assumed to have the deterministic initial state S0 (all species must be included here!). The bounds are computed via an SOS program of degree d, hence can be tightened by increasing d. This computation requires a solver that can deal with exponential cone constraints.</p><p>For numerical stability, it is recommended to provide scales of the expected magnitude of molecular counts for the different species at steady state. If the system is <em>closed</em> it is also possible to enable auto_scaling which will find the maximum molecular counts for each species under stoichiometry constraints (via LP).</p><p>If the initial condition of the reaction network under investigation is unknown or irrelevant, simply call</p><pre><code class="language-none">stationary_covariance_ellipsoid(rn::ReactionSystem, S, d::Int, solver,
				scales = Dict(s =&gt; 1 for s in species(rn)))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FHoltorf/MarkovBounds.jl/blob/9e60607c4615fcbbfd338fbe7b6cbc3ba4459b73/src/sos_programs_stationary.jl#L212-L236">source</a></section></article><h1 id="Bounds-on-Transient-Moments-of-Markov-Processes"><a class="docs-heading-anchor" href="#Bounds-on-Transient-Moments-of-Markov-Processes">Bounds on Transient Moments of Markov Processes</a><a id="Bounds-on-Transient-Moments-of-Markov-Processes-1"></a><a class="docs-heading-anchor-permalink" href="#Bounds-on-Transient-Moments-of-Markov-Processes" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="MarkovBounds.transient_polynomial-Tuple{MarkovProcess, Dict, AbstractPolynomialLike, Int64, AbstractVector{var&quot;#s25&quot;} where var&quot;#s25&quot;&lt;:Real, Any}" href="#MarkovBounds.transient_polynomial-Tuple{MarkovProcess, Dict, AbstractPolynomialLike, Int64, AbstractVector{var&quot;#s25&quot;} where var&quot;#s25&quot;&lt;:Real, Any}"><code>MarkovBounds.transient_polynomial</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">transient_polynomial(MP::MarkovProcess, μ0::Dict, v::APL, d::Int, trange::AbstractVector{&lt;:Real}, solver)</code></pre><p>returns a <em>lower</em> bound on 𝔼[v(x(T))] where v is a polynomial and x(T) the state of the Markov process MP at time T. μ0 encodes the distribution of the initial state of the process in terms of its moments; specifically, it maps monomials to the respective moments of the initial distribution. trange is an <em>ordered</em> collection of time points used to discretize the time horizon [0,T], i.e., trange[end] = T. Populating trange and increasing d improves the computed bound.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FHoltorf/MarkovBounds.jl/blob/9e60607c4615fcbbfd338fbe7b6cbc3ba4459b73/src/sos_programs_transient.jl#L54-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MarkovBounds.transient_mean-Tuple{MarkovProcess, Dict, AbstractPolynomialLike, Int64, AbstractVector{var&quot;#s25&quot;} where var&quot;#s25&quot;&lt;:Real, Any}" href="#MarkovBounds.transient_mean-Tuple{MarkovProcess, Dict, AbstractPolynomialLike, Int64, AbstractVector{var&quot;#s25&quot;} where var&quot;#s25&quot;&lt;:Real, Any}"><code>MarkovBounds.transient_mean</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">transient_mean(MP::MarkovProcess, μ0::Dict, x::APL, d::Int, trange::AbstractVector{&lt;:Real}, solver)</code></pre><p>returns a <em>lower</em> and <em>upper</em> bound on 𝔼[v(x(T))] where v is a polynomial and x(T) the state of the Markov process MP at time T. μ0 encodes the distribution of the initial state of the process in terms of its moments; specifically, it maps monomials to the respective moments of the initial distribution. trange is an <em>ordered</em> collection of time points used to discretize the time horizon [0,T], i.e., trange[end] = T. Populating trange and increasing d improves the computed bounds.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FHoltorf/MarkovBounds.jl/blob/9e60607c4615fcbbfd338fbe7b6cbc3ba4459b73/src/sos_programs_transient.jl#L81-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MarkovBounds.transient_mean" href="#MarkovBounds.transient_mean"><code>MarkovBounds.transient_mean</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">transient_mean(rn::ReactionSystem, S0::Dict, S, d::Int, trange::AbstractVector{&lt;:Number}, solver,
		scales = Dict(s =&gt; 1 for s in species(rn));
		auto_scaling = false)</code></pre><p>returns a <em>lower</em> and <em>upper</em> bound on the mean of the molecular count of species S in reaction network rn at time T. S0 refers to the <em>deterministic</em> initial state of the reaction system (including all species!). trange is an <em>ordered</em> collection of time points used to discretize the time horizon [0,T], i.e., trange[end] = T. Populating trange and increasing d improves the computed bounds.</p><p>For numerical stability, it is recommended to provide scales of the expected magnitude of molecular counts for the different species at steady state. If the system is <em>closed</em> it is also possible to enable auto_scaling which will find the maximum molecular counts for each species under stoichiometry constraints (via LP).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FHoltorf/MarkovBounds.jl/blob/9e60607c4615fcbbfd338fbe7b6cbc3ba4459b73/src/sos_programs_transient.jl#L108-L125">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MarkovBounds.transient_variance-Tuple{MarkovProcess, Dict, AbstractPolynomialLike, Int64, AbstractVector{var&quot;#s25&quot;} where var&quot;#s25&quot;&lt;:Real, Any}" href="#MarkovBounds.transient_variance-Tuple{MarkovProcess, Dict, AbstractPolynomialLike, Int64, AbstractVector{var&quot;#s25&quot;} where var&quot;#s25&quot;&lt;:Real, Any}"><code>MarkovBounds.transient_variance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">transient_variance(MP::MarkovProcess, μ0::Dict, v::APL, d::Int, trange::AbstractVector{&lt;:Real}, solver)</code></pre><p>returns an <em>upper</em> bound on 𝔼[v(x(T))²] - 𝔼[v(x(T))]² where v is a polynomial and x(T) the state of the Markov process MP at time T.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FHoltorf/MarkovBounds.jl/blob/9e60607c4615fcbbfd338fbe7b6cbc3ba4459b73/src/sos_programs_transient.jl#L135-L140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MarkovBounds.transient_variance" href="#MarkovBounds.transient_variance"><code>MarkovBounds.transient_variance</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">transient_variance(rn::ReactionSystem, S0::Dict, S, d::Int, trange::AbstractVector{&lt;:Real}, solver,
		    scales = Dict(s =&gt; 1 for s in species(rn));
			auto_scaling = false)</code></pre><p>returns an <em>upper</em> bound on the variance of species S in the reaction network rn at time T. S0 refers to the <em>deterministic</em> initial state of the reaction system (including all species!). trange is an <em>ordered</em> collection of time points used to discretize the time horizon [0,T], i.e., trange[end] = T. Populating trange and increasing d improves the computed bounds.</p><p>For numerical stability, it is recommended to provide scales of the expected magnitude of molecular counts for the different species at steady state. If the system is <em>closed</em> it is also possible to enable auto_scaling which will find the maximum molecular counts for each species under stoichiometry constraints (via LP).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FHoltorf/MarkovBounds.jl/blob/9e60607c4615fcbbfd338fbe7b6cbc3ba4459b73/src/sos_programs_transient.jl#L183-L200">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MarkovBounds.transient_covariance_ellipsoid-Tuple{MarkovProcess, Dict, Vector{AbstractPolynomialLike}, Int64, AbstractVector{var&quot;#s25&quot;} where var&quot;#s25&quot;&lt;:Real, Any}" href="#MarkovBounds.transient_covariance_ellipsoid-Tuple{MarkovProcess, Dict, Vector{AbstractPolynomialLike}, Int64, AbstractVector{var&quot;#s25&quot;} where var&quot;#s25&quot;&lt;:Real, Any}"><code>MarkovBounds.transient_covariance_ellipsoid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">transient_covariance_ellipsoid(MP::MarkovProcess, μ0::Dict, v::Vector{APL}, d::Int, trange::AbstractVector{&lt;:Real}, solver)</code></pre><p>returns an <em>upper</em> bound on the volume of the covariance ellipsoid det(𝔼(v(x(T))v(x(T))ᵀ)), where v is a polynomial and x(T) the state of the Markov process MP at time T.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FHoltorf/MarkovBounds.jl/blob/9e60607c4615fcbbfd338fbe7b6cbc3ba4459b73/src/sos_programs_transient.jl#L209-L214">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MarkovBounds.transient_covariance_ellipsoid" href="#MarkovBounds.transient_covariance_ellipsoid"><code>MarkovBounds.transient_covariance_ellipsoid</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">transient_covariance_ellipsoid(rn::ReactionSystem, S0::Dict, S::AbstractVector, d::Int, trange::AbstractVector{&lt;:Real}, solver,
						scales = Dict(s =&gt; 1 for s in species(rn));
						auto_scaling = false)</code></pre><p>returns an <em>upper</em> bound on the volume of the covariance ellipsoid associated with any collection of chemical species in the reaction network rn at time T. S0 refers to the <em>deterministic</em> initial state of the reaction system (including all species!). trange is an <em>ordered</em> collection of time points used to discretize the time horizon [0,T], i.e., trange[end] = T. Populating trange and increasing d improves the computed bounds.</p><p>For numerical stability, it is recommended to provide scales of the expected magnitude of molecular counts for the different species at steady state. If the system is <em>closed</em> it is also possible to enable auto_scaling which will find the maximum molecular counts for each species under stoichiometry constraints (via LP).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FHoltorf/MarkovBounds.jl/blob/9e60607c4615fcbbfd338fbe7b6cbc3ba4459b73/src/sos_programs_transient.jl#L265-L282">source</a></section></article><h1 id="Bounds-on-Stochastic-Optimal-Control-Problems"><a class="docs-heading-anchor" href="#Bounds-on-Stochastic-Optimal-Control-Problems">Bounds on Stochastic Optimal Control Problems</a><a id="Bounds-on-Stochastic-Optimal-Control-Problems-1"></a><a class="docs-heading-anchor-permalink" href="#Bounds-on-Stochastic-Optimal-Control-Problems" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="MarkovBounds.optimal_control-Tuple{ControlProcess, Dict, Int64, AbstractVector{var&quot;#s25&quot;} where var&quot;#s25&quot;&lt;:Real, Any}" href="#MarkovBounds.optimal_control-Tuple{ControlProcess, Dict, Int64, AbstractVector{var&quot;#s25&quot;} where var&quot;#s25&quot;&lt;:Real, Any}"><code>MarkovBounds.optimal_control</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">optimal_control(CP::ControlProcess, μ0::Dict, d::Int, trange::AbstractVector{&lt;:Real}, solver)</code></pre><p>returns a <em>lower</em> bound on the objective value of the (stochastic) optimal control problem specified by CP. μ0 encodes information about the distribution of the initial state of the process; specifically, μ0 maps a given monomial to the corresponding moment of the initial distribution. trange refers to an <em>ordered</em> set of time points discretizing the control horizon. trange[end] should coincide with the end of the control horizon, i.e., trange[end] = Inf in case of an infinite horizon problem. The bound is computed via a SOS program of degree d solved with an appropriate method given by solver.</p><p>The bound can be tightened by populating trange or increasing d.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FHoltorf/MarkovBounds.jl/blob/9e60607c4615fcbbfd338fbe7b6cbc3ba4459b73/src/sos_programs_control.jl#L3-L16">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 6 July 2021 20:42">Tuesday 6 July 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
