export JumpProcess, ReactionProcess, DriftProcess, DiffusionProcess, LangevinProcess, JumpDiffusionProcess, ControlProcess,
       MarkovProcess, LagrangeMayer, Lagrange, Mayer, ExitProbability, TerminalSetProbability,
       inf_generator, extended_inf_generator

"""
    MarkovProcess

An abstract type to define stochastic processes that are supported by MarkovBounds.jl. 
"""
abstract type MarkovProcess end

"""
    DriftProcess(x, f, X = FullSpace();
                 iv = _variable("t"), controls = [], poly_vars = Dict())

constructor returns `DriftProcess` object with fields
* `x` - vector containing the system state. Can be specified both as Variable type object
        from DynamicPolynomials.jl or Num type object generated by ModelingToolkit.jl. 
        In the latter case, Variable variables with analogous names are generated automatically and
        a dictionary is assembled that keeps track of this transformation.
* `f` - vector containing the drift function for the process. 
* `iv` - independent variable of the process (usually time)
* `controls` - vector of control variables (empty if there are none)
* `poly_vars` - Dict mapping symbolic variables created by Catalyst.jl or ModelingToolkit.jl to generated Variable placeholders.
"""
@concrete mutable struct DriftProcess <: MarkovProcess
    x # state
    f # propensities
    X # state space enclosure
    iv
    controls
    poly_vars # needed if process defined in terms of Symbolics.jl variables
end

function DriftProcess(x::Vector{<:Variable}, f::Vector{<:APL}, X = FullSpace();
                      iv = _variable("t"), controls = VAR[], poly_vars = Dict())
    return DriftProcess(x, polynomial.(f), X, iv, controls, poly_vars)
end 

"""
    JumpProcess(x, a, h, X = FullSpace();
                iv = Variable("t"), controls = [], poly_vars = Dict())

constructor returns `JumpProcess` object with fields
* `x` - vector containing the system state. Can be specified both as Variable type object
        from DynamicPolynomials.jl or Num type object generated by Catalyst.jl/ModelingToolkit.jl. 
        In the latter case, Variable variables with analogous names are generated automatically and
        a dictionary is assembled that keeps track of this transformation.
* `a` - vector containing the rate coefficients for each independent jump in the system
* `h` - vector of vectors containing the jump functions 
* `X` - basic semialgebraic set enclosing the state space of the process
* `iv` - independent variable of the process (usually time)
* `controls` - vector of control variables (empty if there are none)
* `poly_vars` - Dict mapping symbolic variables created by Catalyst.jl or ModelingToolkit.jl to generated Variable placeholders.
"""
@concrete mutable struct JumpProcess <: MarkovProcess
    x # state
    a # propensities
    h # jumps
    X # state space enclosure
    iv
    controls
    poly_vars # needed if process defined in terms of Symbolics.jl variables
end

function JumpProcess(x::Vector{<:Variable}, a::Vector{<:APL}, h::Vector{<:Vector{<:APL}}, X = FullSpace();
                     iv = _variable("t"), controls = VAR[], poly_vars = Dict())
    return JumpProcess(x, polynomial.(a), map(p -> polynomial.(p), h), X, iv, controls, poly_vars)
end

JumpProcess(x::Variable, a::APL, h::APL, X = FullSpace(); iv = _variable("t"), controls = VAR[]) =
            JumpProcess([x], [a], [[h]], X; iv=iv, controls = (controls isa Vector ? controls : [controls]))
JumpProcess(x::Variable, a::Vector{<:APL}, h::Vector{<:APL}, X = FullSpace(); iv = _variable("t"), controls = VAR[]) =
            JumpProcess([x], a, [[hi] for hi in h], X; iv = iv, controls = (controls isa Vector ? controls : [controls]))

"""
    ReactionProcess(rn::ReactionSystem, params = Dict())

constructor returns `ReactionProcess` object generated from Catalyst.jl `ReactionSystem` object with given parameters.
The fields of ReactionProcess objects are
* `ReactionSystem`- underlying ReactionSystem object as generated by Catalyst.jl
* `JumpProcess` - JumpProcess object describing a `JumpProcess` that is equivalent to the stochastic reaction network described by ReactionSystem
* `species_to_index` - Dictionary mapping chemical species to its internally used variable species_to_index
* `species_to_state` - Dictionary mapping species to equivalent state in the JumpProcess
* `state_to_species` - Dictionary mapping state in `JumpProcess` to species in reaction network
"""
@concrete mutable struct ReactionProcess <: MarkovProcess
    ReactionSystem<:ReactionSystem
    JumpProcess<:JumpProcess
    species_to_index
    species_to_state
    state_to_species
end

function ReactionProcess(rn::ReactionSystem, params = Dict())
    specs = species(rn)
    S = prodstoichmat(rn) - substoichmat(rn)
    n = length(specs)
    @polyvar(x[1:n])
    spec2idx = Dict(specs[i] => i for i in 1:n)
    spec2state = Dict(specs[i] => polynomial(x[i]) for i in 1:n)
    state2spec = Dict(polynomial(x[i]) => specs[i] for i in 1:n)
    props = reformat_reactions(reactions(rn), spec2idx, x, params)
    jumps = reformat_jumps(S, spec2idx, x)
    support = intersect([@set(x[i] >= 0) for i in 1:n]...)
    return ReactionProcess(rn, JumpProcess(x,props,jumps,support), spec2idx, spec2state, state2spec)
end

"""
    DiffusionProcess(x, f, σ, X = FullSpace();
                     iv = _variable("t"), controls = [], poly_vars = Dict())

constructor returns `DiffusionProcess` object with fields
* `x` - vector containing the system state. Can be specified both as Variable type object
        from DynamicPolynomials.jl or Num type object generated by Catalyst.jl/ModelingToolkit.jl. 
        In the latter case, Variable variables with analogous names are generated automatically and
        a dictionary is assembled that keeps track of this transformation.
* `f` - vector of drift coefficients for each state
* `σ` - diffusion matrix of the process
* `X` - basic semialgebraic set enclosing the state space of the process
* `iv` - independent variable of the process (usually time)
* `controls` - vector of control variables (empty if there are none)
* `poly_vars` - Dict mapping symbolic variables created by Catalyst.jl or ModelingToolkit.jl to generated Variable placeholders.
"""
@concrete mutable struct DiffusionProcess <: MarkovProcess
    x  # state
    f # drift
    σ # diffusion matrix
    X # support
    iv
    controls
    poly_vars # needed if process defined in terms of symbolics.jl variables
end

function DiffusionProcess(x::Vector{<:Variable}, f::Vector{<:APL}, σ::Matrix{<:APL}, X = FullSpace();
                          iv = _variable("t"), controls = VAR[], poly_vars = Dict())
    return DiffusionProcess(x, polynomial.(f), polynomial.(σ), X, iv, controls, poly_vars)
end

DiffusionProcess(x::Variable, f::APL, σ::APL, X = FullSpace(); iv::Variable = _variable("t"), controls = VAR[]) =
                 DiffusionProcess([x], [f], reshape([σ],1,1), X; iv=iv, controls = (controls isa Vector ? controls : [controls]))
                
@concrete mutable struct LangevinProcess <: MarkovProcess
    ReactionSystem<:ReactionSystem
    DiffusionProcess<:DiffusionProcess
    species_to_index
    species_to_state
    state_to_species
end

function LangevinProcess(rn::ReactionSystem, params = Dict())
    specs = species(rn)
    S = prodstoichmat(rn) - substoichmat(rn)
    n = length(specs)
    @polyvar(x[1:n])
    spec2idx = Dict(specs[i] => i for i in 1:n)
    spec2state = Dict(specs[i] => x[i] for i in 1:n)
    state2spec = Dict(x[i] => specs[i] for i in 1:n)
    props = polynomial.(reformat_reactions(reactions(rn), spec2idx, x, params))
    drift = S*props
    diff = [sum(S[i,k]*S[j,k]*props[k] for k in eachindex(props)) for i in 1:n, j in 1:n]
    support = intersect([@set(x[i] >= 0) for i in 1:n]...)
    return LangevinProcess(rn, DiffusionProcess(x,drift,diff,support), spec2idx, spec2state, state2spec)
end

"""
    JumpDiffusionProcess(x, a, h, f, σ, X = FullSpace()
                         iv = _variable("t"), controls = [], poly_vars = Dict())

constructor returns `JumpDiffusionProcess` object with fields
* `x` - vector containing the system state. Can be specified both as Variable type object
        from DynamicPolynomials.jl or Num type object generated by Catalyst.jl/ModelingToolkit.jl. 
        In the latter case, Variable variables with analogous names are generated automatically and
        a dictionary is assembled that keeps track of this transformation.
* `a` - vector containing the rate coefficients for each independent jump in the system
* `h` - vector of vectors containing the jump functions 
* `f` - vector of drift coefficients for each state
* `σ` - diffusion matrix of the process
* `X` - basic semialgebraic set enclosing the state space of the process
* `iv` - independent variable of the process (usually time)
* `controls` - vector of control variables (empty if there are none)
* `poly_vars` - Dict mapping symbolic variables created by Catalyst.jl or ModelingToolkit.jl to generated Variable placeholders.
"""
@concrete mutable struct JumpDiffusionProcess <: MarkovProcess
    x # state
    a # propensities
    h # jumps
    f # drift
    σ # diffusion matrix
    X # state space enclosure
    iv
    controls
    poly_vars # needed if process defined in terms of symbolics.jl variables
end

function JumpDiffusionProcess(x::Vector{<:Variable}, a::Vector{<:APL}, h::Vector{<:Vector{<:APL}}, f::Vector{<:APL}, σ::Matrix{<:APL}, X = FullSpace();
                              iv = _variable("t"), controls = VAR[], poly_vars = Dict())
    return JumpDiffusionProcess(x, polynomial.(a), map(p -> polynomial.(p), h), polynomial.(f), polynomial.(σ), X, iv, controls, poly_vars)
end
JumpDiffusionProcess(x::Variable, a::APL, h::APL, f::APL, σ::APL, X = Fullspace(); iv = _variable("t"), controls = VAR[]) =
                     JumpDiffusionProcess([x], [a], [[h]], [f], reshape(σ,1,1), X; iv=iv, controls=(controls isa Vector ? controls : [controls]))
JumpDiffusionProcess(x::Variable, a::Vector{<:APL}, h::Vector{<:APL}, f::APL, σ::APL, X = Fullspace(); iv = _variable("t"), controls=VAR[]) =
                     JumpDiffusionProcess([x], a, [[hi] for hi in h], [f], reshape(σ,1,1), X; iv=iv, controls=(controls isa Vector ? controls : [controls]))

function JumpDiffusionProcess(JP::JumpProcess, DP::DiffusionProcess)
    @assert all(JP.x .== DP.x) "The jump and diffusion process must have the same state"
    return JumpDiffusionProcess(JP.x, JP.a, JP.h, DP.f, DP.σ, intersect(DP.X, JP.X), iv = JP.iv, controls = JP.controls)
end

"""
    ControlProcess(MP::MarkovProcess, T::Real, U, obj, PCs = [], TCs = [], dis_fac = 0)

constructor returns object of type `ControlProcess` with fields
* `MP` - MarkovProcess to be controlled
* `T` - length of the time horizon (can be Inf)
* `U` - closed basic semialgebraic set describing admissible control actions
* `PathChanceConstraints` - Array of chance path constraints
* `TerminalChanceConstraints` - Array of terminal chance constraints
* `discount_factor` - discount factor for accumulating stage cost
"""
@concrete mutable struct ControlProcess
    MP
    T # time horizon
    U # set of admissible controls
    Objective # objetive function
    PathChanceConstraints
    TerminalChanceConstraints
    discount_factor
    function ControlProcess(MP::MarkovProcess, T::Real, U, obj, PCs = [], TCs = [], dis_fac = 0)
        @assert dis_fac >= 0 "Discount factor must be non-negative."
        if isinf(T)
            @assert dis_fac > 0 "Exponential discounting is required for infinite horizon control problems"
        end
        return new{typeof(MP), typeof(T), typeof(U), typeof(obj), typeof(PCs), typeof(TCs), typeof(dis_fac)}(MP, T, U, obj, PCs, TCs, dis_fac)
    end
end



"""
    ExitProbability

a type used to specify an objective function quantifiying the probability for a supported Markov process 
to exit a specified closed basic semialgebraic set on the time horizon specified in a `ControlProcess` object. 

Fields: 
* X - basic semialgebraic set whose exit probability is to be quantified
"""
@concrete mutable struct ExitProbability
    X
end


"""
    TerminalSetProbability

a type used to specify an objective function quantifiying the probability for a supported Markov process 
to occupy a specified closed basic semialgebraic set at the end of the control horizon specified in a `ControlProcess` object. 

Fields: 
* X - basic semialgebraic set whose occupation probability is to be quantified at the end of the control horizon
"""
@concrete mutable struct TerminalSetProbability
    X
end

@doc raw"""
    LagrangeMayer

a type used to specify an objective function consisting of a Lagrange and Mayer term, i.e., ``\mathbb{E}\left[ \int_{0}^T l(x(t), u(t)) \, dt + m(x(T))\right]``.
The Lagrange and Mayer term are specified in terms of polynomial functions ``l : X \times U \to \mathbb{R}`` and ``m : X \to \mathbb{R}``, respectively.


Fields: 
* `l` - `AbstractPolynomialLike` determining the Lagrange term
* `m` - `AbstractPolynomialLike` determining the Mayer term

If only a Lagrange or Mayer term is neede for specification of the objective function, one can make use of the functions
`Lagrange(l::AbstractPolynomialLike)` and `Mayer(m::AbstractPolynomialLike)` for more convenient model specification.
"""
@concrete mutable struct LagrangeMayer
    l
    m
end

Lagrange(l) = LagrangeMayer(l, polynomial(0)) # not elegant but works
Mayer(m) = LagrangeMayer(polynomial(0), m) # not elegant but works

@concrete mutable struct ChanceConstraint
    X
    α
end


inf_generator(MP::JumpProcess, w::Polynomial) = sum(MP.a[i]*(subs(w, MP.x => MP.h[i]) - w) for i in 1:length(MP.a))
inf_generator(MP::ReactionProcess, w::Polynomial) = inf_generator(MP.JumpProcess,w)
inf_generator(MP::DriftProcess, w::Polynomial) = MP.f'*∂(w,MP.x)
inf_generator(MP::DiffusionProcess, w::Polynomial) = MP.f'*∂(w,MP.x) + 1/2*sum(∂²(w,MP.x,MP.x) .* MP.σ)
inf_generator(MP::JumpDiffusionProcess, w::Polynomial) = MP.f'*∂(w,MP.x) + 1/2*sum(∂²(w,MP.x,MP.x) .* MP.σ) + sum(MP.a[i]*(subs(w, MP.x => MP.h[i]) - w) for i in 1:length(MP.a))
extended_inf_generator(MP::MarkovProcess, w::Polynomial; scale = 1) = ∂(w,MP.iv) + scale*inf_generator(MP, w)

function inf_generator(MP::JumpProcess, w::Dict, idx::Tuple{Int, Int}, p::Partition)
    k, v = idx
    x_v = props(p.graph, v)[:cell].x
    gen = 0
    for i in 1:length(MP.a)        
        if isempty(intersect(MP.a[i].x.vars, MP.controls)) 
            prop = MP.a[i](MP.x => x_v)
            skip = prop == 0 ? true : false
        else
            prop = subs(MP.a[i], MP.x => x_v)
            skip = prop == 0 ? true : false
        end
        if !skip
            x_u = [h(MP.x => x_v) for h in MP.h[i]]
            u = p.get_vertex(x_u)
            skip = u == - 1 ? true : false
        end
        if !skip
            if props(p.graph, u)[:cell] isa Singleton
                gen += prop*(w[k,u] - w[k,v])
            else
                gen += prop*(subs(w[k,u], MP.x => x_u) - w[k,v])
            end
        end
    end
    return gen
end

function inf_generator(MP::JumpProcess, w::Dict, v::Int, p::Partition)
    x_v = props(p.graph, v)[:cell].x
    gen = 0
    for i in 1:length(MP.a)
        if isempty(intersect(MP.a[i].x.vars, MP.controls)) 
            prop = MP.a[i](MP.x => x_v)
            skip = prop == 0 ? true : false
        else
            prop = subs(MP.a[i], MP.x => x_v)
            skip = prop == 0 ? true : false
        end
        if !skip
            x_u = [h(MP.x => x_v) for h in MP.h[i]]
            u = p.get_vertex(x_u)
            skip = u == - 1 ? true : false
        end
        if !skip
            if props(p.graph, u)[:cell] isa Singleton
                gen += prop*(w[u] - w[v])
            else
                gen += prop*(subs(w[u], MP.x => x_u) - w[v])
            end
        end
    end
    return gen
end

extended_inf_generator(MP::JumpProcess, w, v, P::Partition; scale = 1) = ∂(w[v],MP.iv) + scale*inf_generator(MP, w, v, P)

@concrete mutable struct Bound
    value<:Real
    model<:Model
    partition
    w
end
